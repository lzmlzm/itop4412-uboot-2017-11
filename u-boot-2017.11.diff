diff -rupN u-boot-2017.11/arch/arm/dts/exynos4412-itop4412.dts u-boot-2017.11-itop4412/arch/arm/dts/exynos4412-itop4412.dts
--- u-boot-2017.11/arch/arm/dts/exynos4412-itop4412.dts	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/dts/exynos4412-itop4412.dts	2018-10-28 16:41:13.000000000 +0800
@@ -0,0 +1,67 @@
+/*
+ * TOPEET's Exynos4412 based itop board device tree source
+ *
+ * Copyright (c) 2018 Samsung Electronics Co., Ltd.
+ *		http://www.samsung.com
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+/dts-v1/;
+#include "exynos4412.dtsi"
+
+/ {
+	model = "TOPEET iTop 4412 Elite board based on Exynos4412";
+	compatible = "topeet,itop4412-elite", "samsung,exynos4412";
+
+	aliases {
+		i2c0 = "/i2c@13860000";
+		i2c1 = "/i2c@13870000";
+		i2c2 = "/i2c@13880000";
+		i2c3 = "/i2c@13890000";
+		i2c4 = "/i2c@138a0000";
+		i2c5 = "/i2c@138b0000";
+		i2c6 = "/i2c@138c0000";
+		i2c7 = "/i2c@138d0000";
+		serial0 = "/serial@13820000";
+		console = "/serial@13820000";
+		mmc2 = "sdhci@12530000";
+		mmc4 = "dwmmc@12550000";
+	};
+
+	serial@13820000 {
+		status = "okay";
+	};
+
+	ehci@12580000 {
+		compatible = "samsung,exynos-ehci";
+		reg = <0x12580000 0x100>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		status = "okay";
+		/* In order to reset USB ethernet */
+		samsung,vbus-gpio = <&gpc0 1 0>;
+		phy {
+			compatible = "samsung,exynos-usb-phy";
+			reg = <0x125B0000 0x100>;
+		};
+	};
+};
+
+&sdhci2 {
+	samsung,bus-width = <4>;
+	samsung,timing = <1 2 3>;
+	cd-gpios = <&gpx0 7 0>;
+	status = "okay";
+};
+
+&mshc_0 {
+	samsung,bus-width = <8>;
+	samsung,timing = <2 1 0>;
+	samsung,removable = <0>;
+	fifoth_val = <0x203f0040>;
+	bus_hz = <400000000>;
+	div = <0x3>;
+	index = <4>;
+	status = "okay";
+};
diff -rupN u-boot-2017.11/arch/arm/include/asm/mach-types.h u-boot-2017.11-itop4412/arch/arm/include/asm/mach-types.h
--- u-boot-2017.11/arch/arm/include/asm/mach-types.h	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/include/asm/mach-types.h	2018-07-14 23:37:38.000000000 +0800
@@ -5057,4 +5057,5 @@
 #define MACH_TYPE_NASM25               5112
 #define MACH_TYPE_TOMATO               5113
 #define MACH_TYPE_OMAP3_MRC3D          5114
+#define MACH_TYPE_ITOP4412             5115
 #endif
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/Kconfig u-boot-2017.11-itop4412/arch/arm/mach-exynos/Kconfig
--- u-boot-2017.11/arch/arm/mach-exynos/Kconfig	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/Kconfig	2018-07-14 20:03:29.000000000 +0800
@@ -60,6 +60,10 @@ config TARGET_ORIGEN
 	bool "Exynos4412 Origen board"
 	select SUPPORT_SPL
 
+config TARGET_ITOP4412
+	bool "Exynos4412 iTop-4412 board"
+	select SUPPORT_SPL
+
 config TARGET_TRATS2
 	bool "Exynos4412 Trat2 board"
 
@@ -156,6 +160,7 @@ source "board/samsung/smdkv310/Kconfig"
 source "board/samsung/trats/Kconfig"
 source "board/samsung/universal_c210/Kconfig"
 source "board/samsung/origen/Kconfig"
+source "board/samsung/itop4412/Kconfig"
 source "board/samsung/trats2/Kconfig"
 source "board/samsung/odroid/Kconfig"
 source "board/samsung/arndale/Kconfig"
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/clock.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/clock.c
--- u-boot-2017.11/arch/arm/mach-exynos/clock.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/clock.c	2018-10-28 23:08:56.000000000 +0800
@@ -783,8 +783,13 @@ static unsigned long exynos4x12_get_uart
 
 static unsigned long exynos4_get_mmc_clk(int dev_index)
 {
+#ifdef CONFIG_ITOP4412
+	struct exynos4x12_clock *clk =
+		(struct exynos4x12_clock *)samsung_get_base_clock();
+#else
 	struct exynos4_clock *clk =
 		(struct exynos4_clock *)samsung_get_base_clock();
+#endif
 	unsigned long uclk, sclk;
 	unsigned int sel, ratio, pre_ratio;
 	int shift = 0;
@@ -833,10 +838,14 @@ static unsigned long exynos4_get_mmc_clk
 /* exynos4: set the mmc clock */
 static void exynos4_set_mmc_clk(int dev_index, unsigned int div)
 {
+#ifdef CONFIG_ITOP4412
+	struct exynos4x12_clock *clk =
+		(struct exynos4x12_clock *)samsung_get_base_clock();
+#else
 	struct exynos4_clock *clk =
 		(struct exynos4_clock *)samsung_get_base_clock();
+#endif
 	unsigned int addr, clear_bit, set_bit;
-
 	/*
 	 * CLK_DIV_FSYS1
 	 * MMC0_PRE_RATIO [15:8], MMC1_PRE_RATIO [31:24]
@@ -912,8 +921,13 @@ static void exynos5420_set_mmc_clk(int d
 /* get_lcd_clk: return lcd clock frequency */
 static unsigned long exynos4_get_lcd_clk(void)
 {
+#ifdef CONFIG_ITOP4412
+	struct exynos4x12_clock *clk =
+		(struct exynos4x12_clock *)samsung_get_base_clock();
+#else
 	struct exynos4_clock *clk =
 		(struct exynos4_clock *)samsung_get_base_clock();
+#endif
 	unsigned long pclk, sclk;
 	unsigned int sel;
 	unsigned int ratio;
@@ -922,7 +936,11 @@ static unsigned long exynos4_get_lcd_clk
 	 * CLK_SRC_LCD0
 	 * FIMD0_SEL [3:0]
 	 */
+#ifdef CONFIG_ITOP4412
+	sel = readl(&clk->src_lcd);
+#else
 	sel = readl(&clk->src_lcd0);
+#endif
 	sel = sel & 0xf;
 
 	/*
@@ -943,7 +961,11 @@ static unsigned long exynos4_get_lcd_clk
 	 * CLK_DIV_LCD0
 	 * FIMD0_RATIO [3:0]
 	 */
+#ifdef CONFIG_ITOP4412
+	ratio = readl(&clk->div_lcd);
+#else
 	ratio = readl(&clk->div_lcd0);
+#endif
 	ratio = ratio & 0xf;
 
 	pclk = sclk / (ratio + 1);
@@ -1063,8 +1085,13 @@ static unsigned long exynos5800_get_lcd_
 
 void exynos4_set_lcd_clk(void)
 {
+#ifdef CONFIG_ITOP4412
+	struct exynos4x12_clock *clk =
+		(struct exynos4x12_clock *)samsung_get_base_clock();
+#else
 	struct exynos4_clock *clk =
 	    (struct exynos4_clock *)samsung_get_base_clock();
+#endif
 
 	/*
 	 * CLK_GATE_BLOCK
@@ -1086,7 +1113,11 @@ void exynos4_set_lcd_clk(void)
 	 * MIPI0_SEL		[12:15]
 	 * set lcd0 src clock 0x6: SCLK_MPLL
 	 */
+#ifdef CONFIG_ITOP4412
+	clrsetbits_le32(&clk->src_lcd, 0xf, 0x6);
+#else
 	clrsetbits_le32(&clk->src_lcd0, 0xf, 0x6);
+#endif
 
 	/*
 	 * CLK_GATE_IP_LCD0
@@ -1098,7 +1129,11 @@ void exynos4_set_lcd_clk(void)
 	 * CLK_PPMULCD0		[5]
 	 * Gating all clocks for FIMD0
 	 */
+#ifdef CONFIG_ITOP4412
+	setbits_le32(&clk->gate_ip_lcd, 1 << 0);
+#else
 	setbits_le32(&clk->gate_ip_lcd0, 1 << 0);
+#endif
 
 	/*
 	 * CLK_DIV_LCD0
@@ -1110,7 +1145,11 @@ void exynos4_set_lcd_clk(void)
 	 * MIPI0_PRE_RATIO	[23:20]
 	 * set fimd ratio
 	 */
+#ifdef CONFIG_ITOP4412
+	clrsetbits_le32(&clk->div_lcd, 0xf, 0x1);
+#else
 	clrsetbits_le32(&clk->div_lcd0, 0xf, 0x1);
+#endif
 }
 
 void exynos5_set_lcd_clk(void)
@@ -1688,8 +1727,8 @@ unsigned long get_mmc_clk(int dev_index)
 void set_mmc_clk(int dev_index, unsigned int div)
 {
 	/* If want to set correct value, it needs to substract one from div.*/
-	if (div > 0)
-		div -= 1;
+	//if (div > 0)
+	//	div -= 1;
 
 	if (cpu_is_exynos5()) {
 		if (proid_is_exynos5420() || proid_is_exynos5422())
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/clock_init_exynos4.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/clock_init_exynos4.c
--- u-boot-2017.11/arch/arm/mach-exynos/clock_init_exynos4.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/clock_init_exynos4.c	2018-08-23 09:34:21.000000000 +0800
@@ -30,12 +30,17 @@
 #include <asm/arch/clk.h>
 #include <asm/arch/clock.h>
 #include "common_setup.h"
-#include "exynos4_setup.h"
 
+#ifdef CONFIG_ITOP4412
+# include "itop4412_setup.h"
+#else
+# include "exynos4_setup.h"
+#endif
 /*
  * system_clock_init: Initialize core clock and bus clock.
  * void system_clock_init(void)
  */
+#ifndef CONFIG_ITOP4412
 void system_clock_init(void)
 {
 	struct exynos4_clock *clk =
@@ -92,3 +97,552 @@ void system_clock_init(void)
 
 	sdelay(0x30000);
 }
+
+#else
+
+/**
+ * freq (ARMCLK) = 1400 MHz at 1.3 V
+ * freq (ACLK_COREM0) = 350 MHz at 1.3V
+ * freq (ACLK_COREM1) = 188 MHz at 1.3 V
+ * freq (PERIPHCLK) = 1400 MHz at 1.3 V
+ * freq (ATCLK) = 214 MHz at 1.3 V
+ * freq (PCLK_DBG) = 107 MHz at 1.3 V
+ * freq (SCLK_DMC) = 400 MHz at 1.0 V
+ * freq (ACLK_DMCD) = 200 MHz at 1.0 V
+ * freq (ACLK_DMCP) = 100 MHz at 1.0 V
+ * freq (ACLK_ACP) = 200 MHz at 1.0 V
+ * freq (PCLK_ACP) = 100 MHz at 1.0 V
+ * freq (SCLK_C2C) = 400 MHz at 1.0 V
+ * freq (ACLK_C2C) = 200 MHz at 1.0 V
+ * freq (ACLK_GDL) = 200 MHz at 1.0 V
+ * freq (ACLK_GPL) = 100 MHz at 1.0 V
+ * freq (ACLK_GDR) = 200 MHz at 1.0 V
+ * freq (ACLK_GPR) = 100 MHz at 1.0 V
+ * freq (ACLK_400_MCUISP) = 400 MHz at 1.0 V
+ * freq (ACLK_200) = 160 MHz at 1.0 V
+ * freq (ACLK_100) = 100 MHz at 1.0 V
+ * freq (ACLK_160) = 160 MHz at 1.0 V
+ * freq (ACLK_133) = 133 MHz at 1.0 V
+ * freq (SCLK_ONENAND) = 160 MHz at 1.0 V
+ */
+void system_clock_init(void)
+{
+	unsigned int set, clr, clr_src_cpu, clr_pll_con0, clr_src_dmc;
+	struct exynos4x12_clock *clk = (struct exynos4x12_clock *)
+						samsung_get_base_clock();
+
+/************************************************************
+ * Step 1:
+ *
+ * Set PDIV, MDIV, and SDIV values (Refer to (A, M, E, V)
+ * Change other PLL control values
+ ************************************************************/
+
+	/**
+	 * Set dividers for MOUTcore = 1000 MHz
+	 *
+	 * DOUTcore    = MOUTcore / (CORE_RATIO +1)      = 1000 MHz (0)
+	 * ACLK_COREM0 = ARMCLK   / (COREM0_RATIO +1)    = 250 MHz (3)
+	 * ACLK_COREM1 = ARMCLK   / (COREM1_RATIO +1)    = 125 MHz (7)
+	 * PERIPHCLK   = DOUTcore / (PERIPH_RATIO + 1)   = 1000 MHz (0)
+	 * ATCLK       = MOUTcore / (ATB_RATIO + 1)      = 200 MHz (4)
+	 * PCLK_DBG    = ATCLK    / (PCLK_DBG_RATIO + 1) = 100 MHz (1)
+	 * SCLKapll    = MOUTapll / (APLL_RATIO + 1)     = 500 MHz (1)
+	 * ARMCLK      = DOUTcore / (CORE2_RATIO + 1)    = 1000 MHz (0)
+	 */
+
+	/** CLK_DIV_CPU0 */
+	clr = CORE_RATIO(7) | COREM0_RATIO(7) | COREM1_RATIO(7) |
+	      PERIPH_RATIO(7) | ATB_RATIO(7) | PCLK_DBG_RATIO(7) |
+	      APLL_RATIO(7) | CORE2_RATIO(7);
+	set = CORE_RATIO(0) | COREM0_RATIO(3) | COREM1_RATIO(7) |
+	      PERIPH_RATIO(0) | ATB_RATIO(4) | PCLK_DBG_RATIO(1) |
+	      APLL_RATIO(1) | CORE2_RATIO(0);
+
+	clrsetbits_le32(&clk->div_cpu0, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_cpu0) & DIV_STAT_CPU0_CHANGING)
+		continue;
+
+	/**
+	 * Set dividers for MOUThpm = 1000 MHz (MOUTapll)
+	 *
+	 * DOUTcopy    = MOUThpm   / (COPY_RATIO + 1)   = 200 MHz (4)
+	 * SCLK_HPM    = DOUTcopy  / (HPM_RATIO + 1)    = 200 MHz (0)
+	 * ACLK_CORES  = ARMCLK    / (CORES_RATIO + 1)  = 1000 MHz (0)
+	 */
+
+	/** CLK_DIV_CPU1 */
+	clr = COPY_RATIO(7) | HPM_RATIO(7) | CORES_RATIO(7);
+	set = COPY_RATIO(4) | HPM_RATIO(0) | CORES_RATIO(0);
+
+	clrsetbits_le32(&clk->div_cpu1, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_cpu1) & DIV_STAT_CPU1_CHANGING)
+		continue;
+
+	/**
+	 * Set dividers for -->
+	 * MOUTdmc  = 800 MHz
+	 * MOUTdphy = 800 MHz
+	 *
+	 * ACLK_ACP  = MOUTdmc   / (ACP_RATIO + 1)      = 200 MHz (3)
+	 * PCLK_ACP  = ACLK_ACP  / (ACP_PCLK_RATIO + 1) = 100 MHz (1)
+	 * SCLK_DPHY = MOUTdphy  / (DPHY_RATIO + 1)     = 400 MHz (1)
+	 * SCLK_DMC  = MOUTdmc   / (DMC_RATIO + 1)      = 400 MHz (1)
+	 * ACLK_DMCD = SCLK_DMC  / (DMCD_RATIO + 1)     = 200 MHz (1)
+	 * ACLK_DMCP = ACLK_DMCD / (DMCP_RATIO + 1)     = 100 MHz (1)
+	 */
+
+	/** CLK_DIV_DMC0 */
+	clr = ACP_RATIO(7) | ACP_PCLK_RATIO(7) | DPHY_RATIO(7) |
+	      DMC_RATIO(7) | DMCD_RATIO(7) | DMCP_RATIO(7);
+	set = ACP_RATIO(3) | ACP_PCLK_RATIO(1) | DPHY_RATIO(1) |
+	      DMC_RATIO(1) | DMCD_RATIO(1) | DMCP_RATIO(1);
+
+	clrsetbits_le32(&clk->div_dmc0, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_dmc0) & DIV_STAT_DMC0_CHANGING)
+		continue;
+
+	/**
+	 * For:
+	 * MOUTg2d = 800 MHz
+	 * MOUTc2c = 800 Mhz
+	 * MOUTpwi = 24 MHz
+	 *
+	 * SCLK_G2D_ACP = MOUTg2d  / (G2D_ACP_RATIO + 1)  = 200 MHz (3)
+	 * SCLK_C2C     = MOUTc2c  / (C2C_RATIO + 1)      = 400 MHz (1)
+	 * SCLK_PWI     = MOUTpwi  / (PWI_RATIO + 1)      = 24 MHz (0)
+	 * ACLK_C2C     = SCLK_C2C / (C2C_ACLK_RATIO + 1) = 200 MHz (1)
+	 * DVSEM_RATIO : It decides frequency for PWM frame time slot in DVS emulation mode.
+	 * DPM_RATIO   : It decides frequency of DPM channel clock.
+	 */
+
+	/** CLK_DIV_DMC1 */
+	clr = G2D_ACP_RATIO(15) | C2C_RATIO(7) | PWI_RATIO(15) |
+	      C2C_ACLK_RATIO(7) | DVSEM_RATIO(127) | DPM_RATIO(127);
+	set = G2D_ACP_RATIO(3) | C2C_RATIO(1) | PWI_RATIO(0) |
+	      C2C_ACLK_RATIO(1) | DVSEM_RATIO(1) | DPM_RATIO(1);
+
+	clrsetbits_le32(&clk->div_dmc1, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_dmc1) & DIV_STAT_DMC1_CHANGING)
+		continue;
+
+	/**
+	 * MOUTmpll        = 800 MHz
+	 * MOUTvpll        = 54 MHz
+	 *
+	 * ACLK_200        = MOUTACLK_200        / (ACLK_200_RATIO + 1)        = 200 MHz (3)
+	 * ACLK_100        = MOUTACLK_100        / (ACLK_100_RATIO + 1)        = 100 MHz (7)
+	 * ACLK_160        = MOUTACLK_160        / (ACLK_160_RATIO + 1)        = 160 MHz (4)
+	 * ACLK_133        = MOUTACLK_133        / (ACLK_133_RATIO + 1)        = 133 MHz (5)
+	 * ONENAND         = MOUTONENAND_1       / (ONENAND_RATIO + 1)         = 160 MHz (0)
+	 * ACLK_266_GPS    = MOUTACLK_266_GPS    / (ACLK_266_GPS_RATIO + 1)    = 266 MHz (2)
+	 * ACLK_400_MCUISP = MOUTACLK_400_MCUISP / (ACLK_400_MCUISP_RATIO + 1) = 400 MHz (1)
+	 */
+
+	/** CLK_DIV_TOP */
+	clr = ACLK_200_RATIO(7) | ACLK_100_RATIO(15) | ACLK_160_RATIO(7) | 
+	      ACLK_133_RATIO(7) | ONENAND_RATIO(7) | ACLK_266_GPS_RATIO(7) | ACLK_400_MCUISP_RATIO(7);
+	set = ACLK_200_RATIO(3) | ACLK_100_RATIO(7) | ACLK_160_RATIO(4) |
+	      ACLK_133_RATIO(5) | ONENAND_RATIO(0) | ACLK_266_GPS_RATIO(2) | ACLK_400_MCUISP_RATIO(1);
+
+	clrsetbits_le32(&clk->div_top, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_top) & DIV_STAT_TOP_CHANGING)
+		continue;
+
+	/**
+	 * ACLK_GDL = MOUTGDL / (GDL_RATIO + 1) = 200 MHz (3)
+	 * ACLK_GPL = MOUTGPL / (GPL_RATIO + 1) = 100 MHz (1)
+	 */
+
+	/** CLK_DIV_LEFTBUS */
+	clr = GDL_RATIO(7) | GPL_RATIO(7);
+	set = GDL_RATIO(3) | GPL_RATIO(1);
+
+	clrsetbits_le32(&clk->div_leftbus, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_leftbus) & DIV_STAT_LEFTBUS_CHANGING)
+		continue;
+
+	/**
+	 * ACLK_GDR = MOUTGDR / (GDR_RATIO + 1) = 200 MHz (3)
+	 * ACLK_GPR = MOUTGPR / (GPR_RATIO + 1) = 100 MHz (1)
+	 */
+
+	/** CLK_DIV_RIGHTBUS */
+	clr = GPR_RATIO(7) | GDR_RATIO(7);
+	set = GPR_RATIO(3) | GDR_RATIO(1);
+
+	clrsetbits_le32(&clk->div_rightbus, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_rightbus) & DIV_STAT_RIGHTBUS_CHANGING)
+		continue;
+
+	/**
+	 * MOUTUART[1-4] = 800 Mhz (MPLL)
+	 *
+	 * SCLK_UART0 = MOUTUART0 / (UART0_RATIO + 1) = 100 MHz (7)
+	 * SCLK_UART1 = MOUTUART1 / (UART1_RATIO + 1) = 100 MHz (7)
+	 * SCLK_UART2 = MOUTUART2 / (UART2_RATIO + 1) = 100 MHz (7)
+	 * SCLK_UART3 = MOUTUART3 / (UART3_RATIO + 1) = 100 MHz (7)
+	 * SCLK_UART4 = MOUTUART4 / (UART4_RATIO + 1) = 100 MHz (7)
+	 */
+	/** CLK_DIV_PERIL0 */
+	clr = UART0_RATIO(15) | UART1_RATIO(15) | UART2_RATIO(15) |
+	      UART3_RATIO(15) | UART4_RATIO(15);
+	set = UART0_RATIO(7) | UART1_RATIO(7) | UART2_RATIO(7) |
+          UART3_RATIO(7) | UART4_RATIO(7);
+
+	clrsetbits_le32(&clk->div_peril0, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_peril0) & DIV_STAT_PERIL0_CHANGING)
+		continue;
+	/**
+	 * For MOUTMMC0-3 = 800 MHz (MPLL)
+	 *
+	 * SCLK_MIPIHSI = MOUTMIPIHSI / (MIPIHSI_RATIO + 1) = 200 MHz (3)
+	 */
+	/* CLK_DIV_FSYS0 */
+	clr = MIPIHSI_RATIO(15);
+	set = MIPIHSI_RATIO(3);
+
+	clrsetbits_le32(&clk->div_fsys0, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_fsys0) & DIV_STAT_FSYS0_CHANGING)
+		continue;
+
+	/**
+	 * For MOUTMMC0-3 = 800 MHz (MPLL)
+	 *
+	 * DOUTMMC0  = MOUTMMC0 / (MMC0_RATIO + 1)     = 100 MHz (7)
+	 * SCLK_MMC0 = DOUTMMC0 / (MMC0_PRE_RATIO + 1) = 50 MHz (1)
+	 * DOUTMMC1  = MOUTMMC1 / (MMC1_RATIO + 1)     = 100 MHz (7)
+	 * SCLK_MMC1 = DOUTMMC1 / (MMC1_PRE_RATIO + 1) = 50 MHz (1)
+	 */
+	/* CLK_DIV_FSYS1 */
+	clr = MMC0_RATIO(15) | MMC0_PRE_RATIO(255) | MMC1_RATIO(15) |
+	      MMC1_PRE_RATIO(255);
+	
+	set = MMC0_RATIO(7) | MMC0_PRE_RATIO(1) | MMC1_RATIO(7) |
+			  MMC1_PRE_RATIO(1);
+
+	clrsetbits_le32(&clk->div_fsys1, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_fsys1) & DIV_STAT_FSYS1_CHANGING)
+		continue;
+
+	/**
+	 * For MOUTmmc0-3 = 800 MHz (MPLL)
+	 *
+	 * DOUTmmc3  = MOUTmmc3 / (MMC2_RATIO + 1)     = 100 MHz (7)
+	 * sclk_mmc3 = DOUTmmc3 / (MMC2_PRE_RATIO + 1) = 50 MHz (1)
+	 * DOUTmmc2  = MOUTmmc2 / (MMC3_RATIO + 1)     = 100 MHz (7)
+	 * sclk_mmc2 = DOUTmmc2 / (MMC3_PRE_RATIO + 1) = 50 MHz (1)
+	*/
+	/* CLK_DIV_FSYS2 */
+	clr = MMC2_RATIO(15) | MMC2_PRE_RATIO(255) | MMC3_RATIO(15) |
+	      MMC3_PRE_RATIO(255);
+	set = MMC2_RATIO(7) | MMC2_PRE_RATIO(1) | MMC3_RATIO(7) |
+	      MMC3_PRE_RATIO(1);
+
+	clrsetbits_le32(&clk->div_fsys2, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_fsys2) & DIV_STAT_FSYS2_CHANGING)
+		continue;
+
+	/**
+	 * For MOUTmmc4 = 800 MHz (MPLL)
+	 *
+	 * DOUTmmc4  = MOUTmmc4 / (MMC4_RATIO + 1)     = 100 MHz (7)
+	 * sclk_mmc4 = DOUTmmc4 / (MMC4_PRE_RATIO + 1) = 50 MHz (1)
+	*/
+	/* CLK_DIV_FSYS3 */
+	clr = MMC4_RATIO(15) | MMC4_PRE_RATIO(255);
+	set = MMC4_RATIO(7) | MMC4_PRE_RATIO(1);
+
+	clrsetbits_le32(&clk->div_fsys3, clr, set);
+
+	/* Wait for divider ready status */
+	while (readl(&clk->div_stat_fsys3) & DIV_STAT_FSYS3_CHANGING)
+		continue;
+
+/************************************************************
+ * Step 2:
+ *
+ * Set K, AFC, MRR, MFR values if necessary 
+ * (Refer to (A, M, E, V)PLL_CON1 SFRs)
+ * Turn on a PLL (Refer to (A, M, E, V) PLL_CON0 SFRs)
+ ************************************************************/
+
+	/* Set APLL to 1000MHz */
+	/** APLL_CON1 */
+	clr = AFC(31) | LOCK_CON_DLY(31) | LOCK_CON_IN(3) |
+	      LOCK_CON_OUT(3) |FEED_EN(1)| AFC_ENB(1) |
+	      DCC_ENB(1) | BYPASS(1) |RESV0(1) | RESV1(1);
+	set = AFC(0) | LOCK_CON_DLY(8) | LOCK_CON_IN(3) |
+	      LOCK_CON_OUT(0) |FEED_EN(0)| AFC_ENB(0) |
+	      DCC_ENB(1) | BYPASS(0) |RESV0(0) | RESV1(0);
+
+	clrsetbits_le32(&clk->apll_con1, clr, set);
+
+	/** APLL_CON0 */
+	clr_pll_con0 = SDIV(7) | PDIV(63) | MDIV(1023) | FSEL(1) | PLL_ENABLE(1);
+	set = SDIV(0) | PDIV(3) | MDIV(125) | FSEL(0) | PLL_ENABLE(1);
+
+	clrsetbits_le32(&clk->apll_con0, clr_pll_con0, set);
+	
+	/* Wait for PLL to be locked */
+	while (!(readl(&clk->apll_con0) & PLL_LOCKED_BIT))
+		continue;
+
+	/* Set MPLL to 800MHz */
+	/** MPLL_CON1 */
+	clr = AFC(31) | LOCK_CON_DLY(31) | LOCK_CON_IN(3) |
+	      LOCK_CON_OUT(3) |FEED_EN(1)| AFC_ENB(1) |
+	      DCC_ENB(1) | BYPASS(1) |RESV0(1) | RESV1(1);
+	set = AFC(0) | LOCK_CON_DLY(8) | LOCK_CON_IN(3) |
+	      LOCK_CON_OUT(0) |FEED_EN(0)| AFC_ENB(0) |
+	      DCC_ENB(1) | BYPASS(0) |RESV0(0) | RESV1(0);
+
+	clrsetbits_le32(&clk->mpll_con1, clr, set);
+
+	/** MPLL_CON0 */
+	clr_pll_con0 = SDIV(7) | PDIV(63) | MDIV(1023) | FSEL(1) | PLL_ENABLE(1);
+	set = SDIV(0) | PDIV(3) | MDIV(100) | FSEL(0) | PLL_ENABLE(1);
+
+	clrsetbits_le32(&clk->mpll_con0, clr_pll_con0, set);
+
+	/* Wait for PLL to be locked */
+	while (!(readl(&clk->mpll_con0) & PLL_LOCKED_BIT))
+		continue;
+
+	/* Set EPLL to 192MHz */
+	/** EPLL_CON2 */
+	clr = ICP_BOOST(7) | EV_FSEL(1) | FVCO_EN(1) | EV_BYPASS(1) |
+	      SSCG_EN(1) | EV_AFC_ENB(1) | EV_DCC_ENB(1) | EXTAFC(1);
+	set = ICP_BOOST(0) | EV_FSEL(1) | FVCO_EN(1) | EV_BYPASS(1) |
+	      SSCG_EN(0) | EV_AFC_ENB(0) | EV_DCC_ENB(1) | EXTAFC(0);
+
+	clrsetbits_le32(&clk->epll_con2, clr, set);
+
+	/** EPLL_CON1 */
+	/* there is null */
+
+	/** EPLL_CON0 */
+	clr_pll_con0 = SDIV(7) | PDIV(63) | MDIV(1023) | FSEL(1) | PLL_ENABLE(1);
+	set = SDIV(2) | PDIV(2) | MDIV(64) | FSEL(0) | PLL_ENABLE(1);
+
+	clrsetbits_le32(&clk->epll_con0, clr_pll_con0, set);
+
+	/* Wait for PLL to be locked */
+	while (!(readl(&clk->epll_con0) & PLL_LOCKED_BIT))
+		continue;
+
+	/* Set VPLL to 54MHz */
+	/** VPLL_CON2 */
+	clr = ICP_BOOST(7) | EV_FSEL(1) | FVCO_EN(1) | EV_BYPASS(1) |
+	      SSCG_EN(1) | EV_AFC_ENB(1) | EV_DCC_ENB(1) | EXTAFC(1);
+	set = ICP_BOOST(0) | EV_FSEL(1) | FVCO_EN(1) | EV_BYPASS(1) |
+	      SSCG_EN(0) | EV_AFC_ENB(0) | EV_DCC_ENB(1) | EXTAFC(0);
+
+	clrsetbits_le32(&clk->vpll_con2, clr, set);
+
+	/** VPLL_CON1 */
+	/* there is null */
+
+	/** VPLL_CON0 */
+	clr_pll_con0 = SDIV(7) | PDIV(63) | MDIV(1023) | FSEL(1) | PLL_ENABLE(1);
+	set = SDIV(3) | PDIV(3) | MDIV(54) | FSEL(0) | PLL_ENABLE(1);
+
+	clrsetbits_le32(&clk->vpll_con0, clr_pll_con0, set);
+
+	/* Wait for PLL to be locked */
+	while (!(readl(&clk->vpll_con0) & PLL_LOCKED_BIT))
+		continue;
+
+/************************************************************
+ *Step 3:
+ *
+ * Wait until the PLL is locked
+ ************************************************************/
+	clr = PLL_LOCKTIME(65535);
+	
+	/** APLL LOCKTIME 1000MHz */
+	set = PLL_LOCKTIME(PDIV(3) * 270);
+	clrsetbits_le32(&clk->apll_lock, clr, set);
+
+	/** MPLL LOCKTIME 800MHz */
+	set = PLL_LOCKTIME(PDIV(3) * 270);
+	clrsetbits_le32(&clk->mpll_lock, clr, set);
+
+	/** EPLL LOCKTIME 192MHz */
+	set = PLL_LOCKTIME(PDIV(2) * 270);
+	clrsetbits_le32(&clk->epll_lock, clr, set);
+
+	/** VPLL LOCKTIME 54MHz */
+	set = PLL_LOCKTIME(PDIV(3) * 270);
+	clrsetbits_le32(&clk->vpll_lock, clr, set);
+
+/************************************************************
+ * Step 4:
+ *
+ * Select the PLL output clock instead of input reference clock,
+ * after PLL output clock is stabilized.
+ * (Refer to CLK_SRC_CPU SFR for APLL and MPLL, 
+ * CLK_SRC_TOP0 for EPLL and VPLL)
+ * Once a PLL is turned on, do not turn it off.
+ ************************************************************/
+
+	/**
+	 * before set system clocks,we switch system clocks src to FINpll
+	 *
+	 * Bit values:                 0  ;  1
+	 * MUX_APLL_SEL:          FIN_PLL ; MOUTAPLLFOUT
+	 * MUX_CORE_SEL:         MOUTAPLL ; SCLKMPLL
+	 * MUX_HPM_SEL:          MOUTAPLL ; SCLKMPLL
+	 * MUX_MPLL_USER_SEL_C:    FINPLL ; FOUTMPLL
+	 */
+	/** CLK_SRC_CPU */
+	clr_src_cpu = MUX_APLL_SEL(1) | MUX_CORE_SEL(1) |
+		      MUX_HPM_SEL(1) | MUX_MPLL_USER_SEL_C(1);
+	set = MUX_APLL_SEL(1) | MUX_CORE_SEL(0) | MUX_HPM_SEL(0) |
+	      MUX_MPLL_USER_SEL_C(1);
+
+	clrsetbits_le32(&clk->src_cpu, clr_src_cpu, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_cpu) & MUX_STAT_CPU_CHANGING)
+		continue;
+
+	/**
+	 * Set CMU_DMC default clocks src to APLL
+	 *
+	 * Bit values:             0  ; 1
+	 * MUX_C2C_SEL:      SCLKMPLL ; SCLKAPLL
+	 * MUX_DMC_BUS_SEL:  SCLKMPLL ; SCLKAPLL
+	 * MUX_DPHY_SEL:     SCLKMPLL ; SCLKAPLL
+	 * MUX_MPLL_SEL:     FINPLL   ; MOUT_MPLL_FOUT
+	 * MUX_PWI_SEL:      0110 (MPLL); 0111 (EPLL); 1000 (VPLL); 0(XXTI)
+	 * MUX_G2D_ACP0_SEL: SCLKMPLL ; SCLKAPLL
+	 * MUX_G2D_ACP1_SEL: SCLKEPLL ; SCLKVPLL
+	 * MUX_G2D_ACP_SEL:  OUT_ACP0 ; OUT_ACP1
+	 */
+	/** CLK_SRC_DMC */
+	clr_src_dmc = MUX_C2C_SEL(1) | MUX_DMC_BUS_SEL(1) |
+		          MUX_DPHY_SEL(1) | MUX_MPLL_SEL(1) |
+		          MUX_PWI_SEL(15) | MUX_G2D_ACP0_SEL(1) |
+		          MUX_G2D_ACP1_SEL(1) | MUX_G2D_ACP_SEL(1);
+	set = MUX_C2C_SEL(0) | MUX_DMC_BUS_SEL(0) | MUX_DPHY_SEL(0) |
+	      MUX_MPLL_SEL(1) | MUX_PWI_SEL(0) | MUX_G2D_ACP0_SEL(0) |
+	      MUX_G2D_ACP1_SEL(0) | MUX_G2D_ACP_SEL(0);
+
+	clrsetbits_le32(&clk->src_dmc, clr_src_dmc, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_dmc) & MUX_STAT_DMC_CHANGING)
+		continue;
+
+	/**
+	 * Set CMU_TOP default clocks src to APLL
+	 *
+	 * Bit values:                           0 ; 1
+	 * MUX_ONENAND_1_SEL           MOUTONENAND ; SCLKVPLL
+	 * MUX_EPLL_SEL                     FINPLL ; FOUTEPLL
+	 * MUX_VPLL_SEL                     FINPLL ; FOUTEPLL
+	 * MUX_ACLK_200_SEL               SCLKMPLL ; SCLKAPLL
+	 * MUX_ACLK_100_SEL               SCLKMPLL ; SCLKAPLL
+	 * MUX_ACLK_160_SEL               SCLKMPLL ; SCLKAPLL
+	 * MUX_ACLK_133_SEL               SCLKMPLL ; SCLKAPLL
+	 * MUX_ONENAND_SEL                ACLK_133 ; ACLK_160
+	 */
+
+	/* CLK_SRC_TOP0 */
+	clr = MUX_ONENAND_1_SEL(1) | MUX_EPLL_SEL(1) | MUX_VPLL_SEL(1) |
+	      MUX_ACLK_200_SEL(1) | MUX_ACLK_100_SEL(1) | MUX_ACLK_160_SEL(1) |
+	      MUX_ACLK_133_SEL(1) | MUX_ONENAND_SEL(1);
+	set = MUX_ONENAND_1_SEL(0) | MUX_EPLL_SEL(1) | MUX_VPLL_SEL(1) |
+	      MUX_ACLK_200_SEL(0) | MUX_ACLK_100_SEL(0) | MUX_ACLK_160_SEL(0) |
+	      MUX_ACLK_133_SEL(0) | MUX_ONENAND_SEL(1);
+
+	clrsetbits_le32(&clk->src_top0, clr, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_top0) & MUX_STAT_TOP0_CHANGING)
+		continue;
+
+	/**
+	 * Bit values:                           0 ; 1
+	 * MUX_ACLK_266_GPS_SEL    SCLKMPLL_USER_T ; SCLKAPLL
+	 * MUX_ACLK_400_MCUISP_SEL SCLKMPLL_USER_T ; SCLKAPLL
+	 * MUX_MPLL_USER_SEL_T              FINPLL ; SCLKMPLLL
+	 * MUX_ACLK_266_GPS_SUB_SEL         FINPLL ; DIVOUT_ACLK_266_GPS
+	 * MUX_ACLK_200_SUB_SEL             FINPLL ; DIVOUT_ACLK_200
+	 * MUX_ACLK_400_MCUISP_SUB_SEL      FINPLL
+	 */
+
+	/* CLK_SRC_TOP1 */
+	clr = MUX_ACLK_266_GPS_SEL(1) | MUX_ACLK_400_MCUISP_SEL(1) |
+	      MUX_MPLL_USER_SEL_T(1) | MUX_ACLK_266_GPS_SUB_SEL(1) |
+	      MUX_ACLK_200_SUB_SEL(1) | MUX_ACLK_400_MCUISP_SUB_SEL(1);
+	set = MUX_ACLK_266_GPS_SEL(0) | MUX_ACLK_400_MCUISP_SEL(0) |
+	      MUX_MPLL_USER_SEL_T(1) | MUX_ACLK_266_GPS_SUB_SEL(1) |
+	      MUX_ACLK_200_SUB_SEL(1) | MUX_ACLK_400_MCUISP_SUB_SEL(1);
+
+	clrsetbits_le32(&clk->src_top1, clr, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_top1) & MUX_STAT_TOP1_CHANGING)
+		continue;
+
+	/* CLK_SRC_LEFTBUS */
+	clr = MUX_GDL_SEL(1) | MUX_MPLL_USER_SEL_L(1);
+	set = MUX_GDL_SEL(0) | MUX_MPLL_USER_SEL_L(1);
+
+	clrsetbits_le32(&clk->src_leftbus, clr, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_leftbus) & MUX_STAT_LEFTBUS_CHANGING)
+		continue;
+
+	/* CLK_SRC_RIGHTBUS */
+	clr = MUX_GDR_SEL(1) | MUX_MPLL_USER_SEL_R(1);
+	set = MUX_GDR_SEL(0) | MUX_MPLL_USER_SEL_R(1);
+
+	clrsetbits_le32(&clk->src_rightbus, clr, set);
+
+	/* Wait for mux change */
+	while (readl(&clk->mux_stat_rightbus) & MUX_STAT_RIGHTBUS_CHANGING)
+		continue;
+
+	/** CLK_SRC_PERIL0 */
+	clr = UART0_SEL(15) | UART1_SEL(15) | UART2_SEL(15) |
+	      UART3_SEL(15) | UART4_SEL(15);
+	set = UART0_SEL(6) | UART1_SEL(6) | UART2_SEL(6) |
+	      UART3_SEL(6) | UART4_SEL(6);
+
+	clrsetbits_le32(&clk->src_peril0, clr, set);
+
+	/** CLK_SRC_FSYS */
+	clr = MMC1_SEL(15) | MMC2_SEL(15) | MMC3_SEL(15) |
+	      MMC4_SEL(15) | MIPIHSI_SEL(1);
+	set = MMC1_SEL(6) | MMC2_SEL(6) | MMC3_SEL(6) |
+	      MMC4_SEL(6) | MIPIHSI_SEL(0);
+
+	clrsetbits_le32(&clk->src_fsys, clr, set);
+}
+#endif
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/dmc_init_exynos4.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/dmc_init_exynos4.c
--- u-boot-2017.11/arch/arm/mach-exynos/dmc_init_exynos4.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/dmc_init_exynos4.c	2018-08-04 10:21:33.000000000 +0800
@@ -26,7 +26,12 @@
 #include <config.h>
 #include <asm/arch/dmc.h>
 #include "common_setup.h"
-#include "exynos4_setup.h"
+
+#ifdef CONFIG_ITOP4412
+# include "itop4412_setup.h"
+#else
+# include "exynos4_setup.h"
+#endif
 
 struct mem_timings mem = {
 	.direct_cmd_msr = {
@@ -48,6 +53,8 @@ struct mem_timings mem = {
 	.dll_resync = FORCE_DLL_RESYNC,
 	.dll_on = DLL_CONTROL_ON,
 };
+
+
 static void phy_control_reset(int ctrl_no, struct exynos4_dmc *dmc)
 {
 	if (ctrl_no) {
@@ -63,6 +70,7 @@ static void phy_control_reset(int ctrl_n
 	}
 }
 
+
 static void dmc_config_mrs(struct exynos4_dmc *dmc, int chip)
 {
 	int i;
@@ -175,7 +183,7 @@ void mem_ctrl_init(int reset)
 	 * 0: full_sync
 	 */
 	writel(1, ASYNC_CONFIG);
-#ifdef CONFIG_ORIGEN
+#ifdef CONFIG_ITOP4412
 	/* Interleave: 2Bit, Interleave_bit1: 0x15, Interleave_bit0: 0x7 */
 	writel(APB_SFR_INTERLEAVE_CONF_VAL, EXYNOS4_MIU_BASE +
 		APB_SFR_INTERLEAVE_CONF_OFFSET);
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/include/mach/power.h u-boot-2017.11-itop4412/arch/arm/mach-exynos/include/mach/power.h
--- u-boot-2017.11/arch/arm/mach-exynos/include/mach/power.h	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/include/mach/power.h	2018-10-18 08:02:25.000000000 +0800
@@ -210,6 +210,214 @@ struct exynos4_power {
 	unsigned int	gps_alive_option;
 };
 
+struct exynos4x12_power {
+	unsigned int	om_stat;
+	unsigned char	res1[0xc];
+	unsigned int	rtc_clko_sel;
+	unsigned int	gnss_rtc_out_ctrl;
+	unsigned int	lpi_denial_mask0;
+	unsigned int	lpi_denial_mask1;
+	unsigned int	lpi_denial_mask2;
+	unsigned int	c2c_ctrl;
+	unsigned char	res2[0x1d8];
+	unsigned int	central_seq_config;
+	unsigned int	res3;
+	unsigned int	central_seq_option;
+	unsigned char	res4[0x1f4];
+	unsigned int	swreset;
+	unsigned int	rst_stat;
+	unsigned int	auto_wdt_reset_disable;
+	unsigned int	mask_wdt_reset_request;
+	unsigned char	res5[0x1f0];
+	unsigned int	wakeup_stat;
+	unsigned int	eint_wakeup_mask;
+	unsigned int	wakeup_mask;
+	unsigned char	res6[0xf4];
+	unsigned int	hdmi_phy_control;
+	unsigned int	usbdevice_phy_control;
+	unsigned int	hsic_1_phy_control;
+	unsigned int	hsic_2_phy_control;
+	unsigned int	mipi_phy0_control;
+	unsigned int	mipi_phy1_control;
+	unsigned int	adc_phy_control;
+	unsigned char	res7[0x64];
+	unsigned int	body_bias_con0;
+	unsigned int	body_bias_con1;
+	unsigned int	body_bias_con2;
+	unsigned int	body_bias_con3;
+	unsigned char	res8[0x70];
+	unsigned int	inform0;
+	unsigned int	inform1;
+	unsigned int	inform2;
+	unsigned int	inform3;
+	unsigned int	inform4;
+	unsigned int	inform5;
+	unsigned int	inform6;
+	unsigned int	inform7;
+	unsigned char	res9[0x1e0];
+	unsigned int	pmu_debug;
+	unsigned char	res10[0x5fc];
+	unsigned int	arm_core0_sys_pwr_reg;
+	unsigned char	res11[0xc];
+	unsigned int	arm_core1_sys_pwr_reg;
+	unsigned char	res12[0x6c];
+	unsigned int	arm_common_sys_pwr_reg;
+	unsigned char	res13[0x3c];
+	unsigned int	arm_cpu_l2_0_sys_pwr_reg;
+	unsigned int	arm_cpu_l2_1_sys_pwr_reg;
+	unsigned char	res14[0x38];
+	unsigned int	cmu_aclkstop_sys_pwr_reg;
+	unsigned int	cmu_sclkstop_sys_pwr_reg;
+	unsigned char	res15[0x4];
+	unsigned int	cmu_reset_sys_pwr_reg;
+	unsigned char	res16[0x10];
+	unsigned int	apll_sysclk_sys_pwr_reg;
+	unsigned int	mpll_sysclk_sys_pwr_reg;
+	unsigned int	vpll_sysclk_sys_pwr_reg;
+	unsigned int	epll_sysclk_sys_pwr_reg;
+	unsigned char	res17[0x8];
+	unsigned int	cmu_clkstop_gps_alive_sys_pwr_reg;
+	unsigned int	cmu_reset_gps_alive_sys_pwr_reg;
+	unsigned int	cmu_clkstop_cam_sys_pwr_reg;
+	unsigned int	cmu_clkstop_tv_sys_pwr_reg;	
+	unsigned int	cmu_clkstop_mfc_sys_pwr_reg;
+	unsigned int	cmu_clkstop_g3d_sys_pwr_reg;
+	unsigned int	cmu_clkstop_lcd0_sys_pwr_reg;
+	unsigned int	cmu_clkstop_isp_sys_pwr_reg;
+	unsigned int	cmu_clkstop_maudio_sys_pwr_reg;
+	unsigned int	cmu_clkstop_gps_sys_pwr_reg;
+	unsigned int	cmu_reset_cam_sys_pwr_reg;
+	unsigned int	cmu_reset_tv_sys_pwr_reg;
+	unsigned int	cmu_reset_mfc_sys_pwr_reg;
+	unsigned int	cmu_reset_g3d_sys_pwr_reg;
+	unsigned int	cmu_reset_lcd0_sys_pwr_reg;
+	unsigned int	cmu_reset_isp_sys_pwr_reg;
+	unsigned int	cmu_reset_maudio_sys_pwr_reg;
+	unsigned int	cmu_reset_gps_sys_pwr_reg;
+	unsigned int	top_bus_sys_pwr_reg;
+	unsigned int	top_retention_sys_pwr_reg;
+	unsigned int	top_pwr_sys_pwr_reg;
+	unsigned char	res18[0x14];
+	unsigned int	logic_reset_sys_pwr_reg;
+	unsigned char	res19[0x1c];
+	unsigned int	onenandxl_mem_sys_pwr_reg;
+	unsigned int	hsi_mem_sys_pwr_reg;
+	unsigned char	res20[0x4];	
+	unsigned int	usbotg_mem_sys_pwr_reg;
+	unsigned int	sdmmc_mem_sys_pwr_reg;
+	unsigned int	cssys_mem_sys_pwr_reg;
+	unsigned int	secss_mem_sys_pwr_reg;
+	unsigned int	potator_mem_sys_pwr_reg;
+	unsigned char	res21[0x20];
+	unsigned int	pad_retention_dram_sys_pwr_reg;
+	unsigned int	pad_retention_maudio_sys_pwr_reg;
+	unsigned char	res22[0x18];
+	unsigned int	pad_retention_gpio_sys_pwr_reg;
+	unsigned int	pad_retention_uart_sys_pwr_reg;
+	unsigned int	pad_retention_mmca_sys_pwr_reg;
+	unsigned int	pad_retention_mmcb_sys_pwr_reg;
+	unsigned int	pad_retention_ebia_sys_pwr_reg;
+	unsigned int	pad_retention_ebib_sys_pwr_reg;
+	unsigned char	res23[0x8];
+	unsigned int	pad_isolation_sys_pwr_reg;
+	unsigned char	res24[0x1c];
+	unsigned int	pad_alv_sel_sys_pwr_reg;
+	unsigned char	res25[0x1c];
+	unsigned int	xusbxti_sys_pwr_reg;
+	unsigned int	xxti_sys_pwr_reg;
+	unsigned char	res26[0x38];
+	unsigned int	ext_regulator_sys_pwr_reg;
+	unsigned char	res27[0x3c];
+	unsigned int	gpio_mode_sys_pwr_reg;
+	unsigned char	res28[0x3c];
+	unsigned int	gpio_mode_maudio_sys_pwr_reg;
+	unsigned char	res29[0x3c];
+	unsigned int	cam_sys_pwr_reg;
+	unsigned int	tv_sys_pwr_reg;
+	unsigned int	mfc_sys_pwr_reg;
+	unsigned int	g3d_sys_pwr_reg;
+	unsigned int	lcd0_sys_pwr_reg;
+	unsigned int	isp_sys_pwr_reg;
+	unsigned int	maudio_sys_pwr_reg;
+	unsigned int	gps_sys_pwr_reg;
+	unsigned int	gps_alive_sys_pwr_reg;
+	unsigned char	res30[0xc5c];
+	unsigned int	arm_core0_configuration;
+	unsigned int	arm_core0_status;
+	unsigned int	arm_core0_option;
+	unsigned char	res31[0x74];
+	unsigned int	arm_core1_configuration;
+	unsigned int	arm_core1_status;
+	unsigned int	arm_core1_option;
+	unsigned char	res32[0x37c];
+	unsigned int	arm_common_option;
+	unsigned char	res33[0x1f4];
+	unsigned int	arm_cpu_l2_0_configuration;
+	unsigned int	arm_cpu_l2_0_status;
+	unsigned char	res34[0x18];
+	unsigned int	arm_cpu_l2_1_configuration;
+	unsigned int	arm_cpu_l2_1_status;
+	unsigned char	res35[0xa00];
+	unsigned int	pad_retention_maudio_option;
+	unsigned char	res36[0xdc];
+	unsigned int	pad_retention_gpio_option;
+	unsigned char	res37[0x1c];
+	unsigned int	pad_retention_uart_option;
+	unsigned char	res38[0x1c];
+	unsigned int	pad_retention_mmca_option;
+	unsigned char	res39[0x1c];
+	unsigned int	pad_retention_mmcb_option;
+	unsigned char	res40[0x1c];
+	unsigned int	pad_retention_ebia_option;
+	unsigned char	res41[0x1c];
+	unsigned int	pad_retention_ebib_option;
+	unsigned char	res42[0x160];
+	unsigned int	ps_hold_control;
+	unsigned char	res43[0xf0];
+	unsigned int	xusbxti_configuration;
+	unsigned int	xusbxti_status;
+	unsigned char	res44[0x14];
+	unsigned int	xusbxti_duration;
+	unsigned int	xxti_configuration;
+	unsigned int	xxti_status;
+	unsigned char	res45[0x14];
+	unsigned int	xxti_duration;
+	unsigned char	res46[0x1dc];
+	unsigned int	ext_regulator_duration;
+	unsigned char	res47[0x5e0];
+	unsigned int	cam_configuration;
+	unsigned int	cam_status;
+	unsigned int	cam_option;
+	unsigned char	res48[0x14];
+	unsigned int	tv_configuration;
+	unsigned int	tv_status;
+	unsigned int	tv_option;
+	unsigned char	res49[0x14];
+	unsigned int	mfc_configuration;
+	unsigned int	mfc_status;
+	unsigned int	mfc_option;
+	unsigned char	res50[0x14];
+	unsigned int	g3d_configuration;
+	unsigned int	g3d_status;
+	unsigned int	g3d_option;
+	unsigned char	res51[0x14];
+	unsigned int	lcd0_configuration;
+	unsigned int	lcd0_status;
+	unsigned int	lcd0_option;
+	unsigned char	res52[0x14];
+	unsigned int	isp_configuration;
+	unsigned int	isp_status;
+	unsigned int	isp_option;
+	unsigned char	res53[0x34];
+	unsigned int	gps_configuration;
+	unsigned int	gps_status;
+	unsigned int	gps_option;
+	unsigned char	res54[0x14];
+	unsigned int	gps_alive_configuration;
+	unsigned int	gps_alive_status;
+	unsigned int	gps_alive_option;
+};
+
 struct exynos4412_power {
 	unsigned char	res1[0x0704];
 	unsigned int	usbhost_phy_control;
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/itop4412_setup.h u-boot-2017.11-itop4412/arch/arm/mach-exynos/itop4412_setup.h
--- u-boot-2017.11/arch/arm/mach-exynos/itop4412_setup.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/itop4412_setup.h	2018-08-04 10:18:04.000000000 +0800
@@ -0,0 +1,599 @@
+#ifndef _ITOP4412_SETUP_H
+#define _ITOP4412_SETUP_H
+
+#include <config.h>
+#include <asm/arch/cpu.h>
+
+#ifdef CONFIG_CLK_800_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_200_200
+#define DRAM_CLK_200
+#endif
+#ifdef CONFIG_CLK_1000_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_400_200
+#define DRAM_CLK_400
+#endif
+
+/* this state is changing for register */
+#define MUX_STAT_CHANGING       0x100
+#define DIV_STAT_CHANGING       0x1
+
+/* A/M/EV PLL_CON0 */
+#define SDIV(x)                 ((x) & 0x7)
+#define PDIV(x)                 (((x) & 0x3f) << 8)
+#define MDIV(x)                 (((x) & 0x3ff) << 16)
+#define FSEL(x)                 (((x) & 0x1) << 27)
+#define PLL_LOCKED_BIT          (0x1 << 29)
+#define PLL_ENABLE(x)           (((x) & 0x1) << 31)
+
+/* A/M PLL_CON1 */
+#define AFC(x)                  ((x) & 0x1f)
+#define LOCK_CON_DLY(x)         (((x) & 0x1f) << 8)
+#define LOCK_CON_IN(x)          (((x) & 0x3) << 12)
+#define LOCK_CON_OUT(x)         (((x) & 0x3) << 14)
+#define FEED_EN(x)              (((x) & 0x1) << 16)
+#define AFC_ENB(x)              (((x) & 0x1) << 20)
+#define DCC_ENB(x)              (((x) & 0x1) << 21)
+#define BYPASS(x)               (((x) & 0x1) << 22)
+#define RESV0(x)                (((x) & 0x1) << 23)
+#define RESV1(x)                (((x) & 0x1) << 24)
+
+/* E/V PLL_CON1 */
+#define K(x)                    ((x) & 0xffff)
+#define MFR(x)                  (((x) & 0xff) << 16)
+#define MRR(x)                  (((x) & 0x1f) << 24)
+#define SEL_PF(x)               (((x) & 0x3) << 29)
+
+/* E/V PLL_CON2 */
+#define ICP_BOOST(x)            ((x) & 0x3)
+#define EV_FSEL(x)              (((x) & 0x1) << 2)
+#define FVCO_EN(x)              (((x) & 0x1) << 3)
+#define EV_BYPASS(x)            (((x) & 0x1) << 4)
+#define SSCG_EN(x)              (((x) & 0x1) << 5)
+#define EV_AFC_ENB(x)           (((x) & 0x1) << 6)
+#define EV_DCC_ENB(x)              (((x) & 0x1) << 7)
+#define EXTAFC(x)               (((x) & 0x1f) << 8)
+
+/* CLK_SRC_CPU */
+#define MUX_APLL_SEL(x)         ((x) & 0x1)
+#define MUX_CORE_SEL(x)         (((x) & 0x1) << 16)
+#define MUX_HPM_SEL(x)          (((x) & 0x1) << 20)
+#define MUX_MPLL_USER_SEL_C(x)  (((x) & 0x1) << 24)
+
+/* CLK_MUX_STAT_CPU */
+#define APLL_SEL(x)             ((x) & 0x7)
+#define CORE_SEL(x)             (((x) & 0x7) << 16)
+#define HPM_SEL(x)              (((x) & 0x7) << 20)
+#define MPLL_USER_SEL_C(x)      (((x) & 0x7) << 24)
+#define MUX_STAT_CPU_CHANGING   (APLL_SEL(MUX_STAT_CHANGING) | \
+				CORE_SEL(MUX_STAT_CHANGING) | \
+				HPM_SEL(MUX_STAT_CHANGING) | \
+				MPLL_USER_SEL_C(MUX_STAT_CHANGING))
+
+/* A/M/E/V PLL_LOCK */
+#define PLL_LOCKTIME(x)         ((x) & 0xffff)
+
+/* CLK_DIV_CPU0 */
+#define CORE_RATIO(x)           ((x) & 0x7)
+#define COREM0_RATIO(x)         (((x) & 0x7) << 4)
+#define COREM1_RATIO(x)         (((x) & 0x7) << 8)
+#define PERIPH_RATIO(x)         (((x) & 0x7) << 12)
+#define ATB_RATIO(x)            (((x) & 0x7) << 16)
+#define PCLK_DBG_RATIO(x)       (((x) & 0x7) << 20)
+#define APLL_RATIO(x)           (((x) & 0x7) << 24)
+#define CORE2_RATIO(x)          (((x) & 0x7) << 28)
+
+/* CLK_DIV_CPU1 */
+#define COPY_RATIO(x)           ((x) & 0x7)
+#define HPM_RATIO(x)            (((x) & 0x7) << 4)
+#define CORES_RATIO(x)          (((x) & 0x7) << 8)
+
+/* CLK_DIV_STAT_CPU0 */
+#define DIV_CORE(x)             ((x) & 0x1)
+#define DIV_COREM0(x)           (((x) & 0x1) << 4)
+#define DIV_COREM1(x)           (((x) & 0x1) << 8)
+#define DIV_PERIPH(x)           (((x) & 0x1) << 12)
+#define DIV_ATB(x)              (((x) & 0x1) << 16)
+#define DIV_PCLK_DBG(x)         (((x) & 0x1) << 20)
+#define DIV_APLL(x)             (((x) & 0x1) << 24)
+#define DIV_CORE2(x)            (((x) & 0x1) << 28)
+
+#define DIV_STAT_CPU0_CHANGING  (DIV_CORE(DIV_STAT_CHANGING) | \
+				DIV_COREM0(DIV_STAT_CHANGING) | \
+				DIV_COREM1(DIV_STAT_CHANGING) | \
+				DIV_PERIPH(DIV_STAT_CHANGING) | \
+				DIV_ATB(DIV_STAT_CHANGING) | \
+				DIV_PCLK_DBG(DIV_STAT_CHANGING) | \
+				DIV_APLL(DIV_STAT_CHANGING) | \
+				DIV_CORE2(DIV_STAT_CHANGING))
+
+/* CLK_DIV_STAT_CPU1 */
+#define DIV_COPY(x)             ((x) & 0x1)
+#define DIV_HPM(x)              (((x) & 0x1) << 4)
+#define DIV_CORES(x)            (((x) & 0x1) << 8)
+
+#define DIV_STAT_CPU1_CHANGING	(DIV_COPY(DIV_STAT_CHANGING) | \
+				DIV_HPM(DIV_STAT_CHANGING) | \
+				DIV_CORES(DIV_STAT_CHANGING))
+
+/* CLK_SRC_DMC */
+#define MUX_C2C_SEL(x)      ((x) & 0x1)
+#define MUX_DMC_BUS_SEL(x)  (((x) & 0x1) << 4)
+#define MUX_DPHY_SEL(x)     (((x) & 0x1) << 8)
+#define MUX_MPLL_SEL(x)     (((x) & 0x1) << 12)
+#define MUX_PWI_SEL(x)      (((x) & 0xf) << 16)
+#define MUX_G2D_ACP0_SEL(x) (((x) & 0x1) << 20)
+#define MUX_G2D_ACP1_SEL(x) (((x) & 0x1) << 24)
+#define MUX_G2D_ACP_SEL(x)  (((x) & 0x1) << 28)
+
+/* CLK_MUX_STAT_DMC */
+#define C2C_SEL(x)          ((x) & 0x7)
+#define DMC_BUS_SEL(x)      (((x) & 0x7) << 4)
+#define DPHY_SEL(x)         (((x) & 0x7) << 8)
+#define MPLL_SEL(x)         (((x) & 0x7) << 12)
+#define G2D_ACP0_SEL(x)     (((x) & 0x7) << 20)
+#define G2D_ACP1_SEL(x)     (((x) & 0x7) << 24)
+#define G2D_ACP_SEL(x)      (((x) & 0x7) << 28)
+
+#define MUX_STAT_DMC_CHANGING   (C2C_SEL(MUX_STAT_CHANGING) | \
+				DMC_BUS_SEL(MUX_STAT_CHANGING) | \
+				DPHY_SEL(MUX_STAT_CHANGING) | \
+				MPLL_SEL(MUX_STAT_CHANGING) |\
+				G2D_ACP0_SEL(MUX_STAT_CHANGING) | \
+				G2D_ACP1_SEL(MUX_STAT_CHANGING) | \
+				G2D_ACP_SEL(MUX_STAT_CHANGING))
+
+/* CLK_DIV_DMC0 */
+#define ACP_RATIO(x)        ((x) & 0x7)
+#define ACP_PCLK_RATIO(x)   (((x) & 0x7) << 4)
+#define DPHY_RATIO(x)       (((x) & 0x7) << 8)
+#define DMC_RATIO(x)        (((x) & 0x7) << 12)
+#define DMCD_RATIO(x)       (((x) & 0x7) << 16)
+#define DMCP_RATIO(x)       (((x) & 0x7) << 20)
+
+/* CLK_DIV_DMC1 */
+#define G2D_ACP_RATIO(x)    ((x) & 0xf)
+#define C2C_RATIO(x)        (((x) & 0x7) << 4)
+#define PWI_RATIO(x)        (((x) & 0xf) << 8)
+#define C2C_ACLK_RATIO(x)   (((x) & 0x7) << 12)
+#define DVSEM_RATIO(x)      (((x) & 0x7f) << 16)
+#define DPM_RATIO(x)        (((x) & 0x7f) << 24)
+
+/* CLK_DIV_STAT_DMC0 */
+#define DIV_ACP(x)          ((x) & 0x1)
+#define DIV_ACP_PCLK(x)     (((x) & 0x1) << 4)
+#define DIV_DPHY(x)         (((x) & 0x1) << 8)
+#define DIV_DMC(x)          (((x) & 0x1) << 12)
+#define DIV_DMCD(x)         (((x) & 0x1) << 16)
+#define DIV_DMCP(x)         (((x) & 0x1) << 20)
+
+#define DIV_STAT_DMC0_CHANGING  (DIV_ACP(DIV_STAT_CHANGING) | \
+				DIV_ACP_PCLK(DIV_STAT_CHANGING) | \
+				DIV_DPHY(DIV_STAT_CHANGING) | \
+				DIV_DMC(DIV_STAT_CHANGING) | \
+				DIV_DMCD(DIV_STAT_CHANGING) | \
+				DIV_DMCP(DIV_STAT_CHANGING))
+
+/* CLK_DIV_STAT_DMC1 */
+#define DIV_G2D_ACP(x)       ((x) & 0x1)
+#define DIV_C2C(x)           (((x) & 0x1) << 4)
+#define DIV_PWI(x)           (((x) & 0x1) << 8)
+#define DIV_C2C_ACLK(x)      (((x) & 0x1) << 12)
+#define DIV_DVSEM(x)         (((x) & 0x1) << 16)
+#define DIV_DPM(x)           (((x) & 0x1) << 24)
+
+#define DIV_STAT_DMC1_CHANGING  (DIV_G2D_ACP(DIV_STAT_CHANGING) | \
+				DIV_C2C(DIV_STAT_CHANGING) | \
+				DIV_PWI(DIV_STAT_CHANGING) | \
+				DIV_C2C_ACLK(DIV_STAT_CHANGING) | \
+				DIV_DVSEM(DIV_STAT_CHANGING) | \
+				DIV_DPM(DIV_STAT_CHANGING))
+
+/* CLK_SRC_TOP0 */
+#define MUX_ONENAND_1_SEL(x)    ((x) & 0x1)
+#define MUX_EPLL_SEL(x)         (((x) & 0x1) << 4)
+#define MUX_VPLL_SEL(x)         (((x) & 0x1) << 8)
+#define MUX_ACLK_200_SEL(x)     (((x) & 0x1) << 12)
+#define MUX_ACLK_100_SEL(x)     (((x) & 0x1) << 16)
+#define MUX_ACLK_160_SEL(x)     (((x) & 0x1) << 20)
+#define MUX_ACLK_133_SEL(x)     (((x) & 0x1) << 24)
+#define MUX_ONENAND_SEL(x)      (((x) & 0x1) << 28)
+
+/* CLK_MUX_STAT_TOP */
+#define ONENAND_1_SEL(x)    ((x) & 0x3)
+#define EPLL_SEL(x)         (((x) & 0x3) << 4)
+#define VPLL_SEL(x)         (((x) & 0x3) << 8)
+#define ACLK_200_SEL(x)     (((x) & 0x3) << 12)
+#define ACLK_100_SEL(x)     (((x) & 0x3) << 16)
+#define ACLK_160_SEL(x)     (((x) & 0x3) << 20)
+#define ACLK_133_SEL(x)     (((x) & 0x3) << 24)
+#define ONENAND_SEL(x)      (((x) & 0x3) << 28)
+
+#define MUX_STAT_TOP0_CHANGING  (ONENAND_1_SEL(MUX_STAT_CHANGING) | \
+				EPLL_SEL(MUX_STAT_CHANGING) | \
+				EPLL_SEL(MUX_STAT_CHANGING) | \
+				VPLL_SEL(MUX_STAT_CHANGING) | \
+				ACLK_200_SEL(MUX_STAT_CHANGING) | \
+				ACLK_100_SEL(MUX_STAT_CHANGING) | \
+				ACLK_160_SEL(MUX_STAT_CHANGING) | \
+				ACLK_133_SEL(MUX_STAT_CHANGING) | \
+				ONENAND_SEL(MUX_STAT_CHANGING))
+
+/* CLK_SRC_TOP1 */
+#define MUX_ACLK_266_GPS_SEL(x)        (((x) & 0x1) << 4)
+#define MUX_ACLK_400_MCUISP_SEL(x)     (((x) & 0x1) << 8)
+#define MUX_MPLL_USER_SEL_T(x)         (((x) & 0x1) << 12)
+#define MUX_ACLK_266_GPS_SUB_SEL(x)    (((x) & 0x1) << 16)
+#define MUX_ACLK_200_SUB_SEL(x)        (((x) & 0x1) << 20)
+#define MUX_ACLK_400_MCUISP_SUB_SEL(x) (((x) & 0x1) << 24)
+
+/* CLK_MUX_STAT_TOP1 */
+#define ACLK_266_GPS_SEL(x)        (((x) & 0x3) << 4)
+#define ACLK_400_MCUISP_SEL(x)     (((x) & 0x3) << 8)
+#define MPLL_USER_SEL_T(x)         (((x) & 0x3) << 12)
+#define ACLK_266_GPS_SUB_SEL(x)    (((x) & 0x3) << 16)
+#define ACLK_200_SUB_SEL(x)        (((x) & 0x3) << 20)
+#define ACLK_400_MCUISP_SUB_SEL(x) (((x) & 0x3) << 24)
+
+#define MUX_STAT_TOP1_CHANGING  (MUX_ACLK_266_GPS_SEL(MUX_STAT_CHANGING) | \
+				ACLK_400_MCUISP_SEL(MUX_STAT_CHANGING) | \
+				MPLL_USER_SEL_T(MUX_STAT_CHANGING) | \
+				ACLK_266_GPS_SUB_SEL(MUX_STAT_CHANGING) | \
+				ACLK_200_SUB_SEL(MUX_STAT_CHANGING) | \
+				ACLK_400_MCUISP_SUB_SEL(MUX_STAT_CHANGING))
+
+/* CLK_DIV_TOP */
+#define ACLK_200_RATIO(x)        ((x) & 0x7)
+#define ACLK_100_RATIO(x)        (((x) & 0xf) << 4)
+#define ACLK_160_RATIO(x)        (((x) & 0x7) << 8)
+#define	ACLK_133_RATIO(x)        (((x) & 0x7) << 12)
+#define	ONENAND_RATIO(x)         (((x) & 0x7) << 16)
+#define	ACLK_266_GPS_RATIO(x)    (((x) & 0x7) << 20)
+#define	ACLK_400_MCUISP_RATIO(x) (((x) & 0x7) << 24)
+
+#define DIV_STAT_TOP_CHANGING    (ACLK_400_MCUISP_RATIO(DIV_STAT_CHANGING) | \
+				ACLK_266_GPS_RATIO(DIV_STAT_CHANGING) | \
+				ONENAND_RATIO(DIV_STAT_CHANGING) | \
+				ACLK_133_RATIO(DIV_STAT_CHANGING) | \
+				ACLK_160_RATIO(DIV_STAT_CHANGING) | \
+				ACLK_100_RATIO(DIV_STAT_CHANGING) | \
+				ACLK_200_RATIO(DIV_STAT_CHANGING))
+
+/* CLK_SRC_LEFTBUS */
+#define	MUX_GDL_SEL(x)         ((x) & 0x1)
+#define	MUX_MPLL_USER_SEL_L(x) (((x) & 0x1) << 4)
+
+/* CLK_MUX_STAT_LEFTBUS */
+#define	GDL_SEL(x)             ((x) & 0x7)
+#define	MPLL_USER_SEL_L(x)     (((x) & 0x7) << 4)
+
+#define MUX_STAT_LEFTBUS_CHANGING    (GDL_SEL(MUX_STAT_CHANGING) | \
+				MPLL_USER_SEL_L(MUX_STAT_CHANGING))
+
+/* CLK_DIV_LEFTBUS */
+#define GDL_RATIO(x)        ((x) & 0x7)
+#define GPL_RATIO(x)        (((x) & 0x7) << 4)
+
+/* CLK_DIV_STAT_LEFTBUS */
+#define DIV_GDL(x)          ((x) & 0x1)
+#define DIV_GPL(x)          (((x) & 0x1) << 4)
+
+#define DIV_STAT_LEFTBUS_CHANGING    (DIV_GDL(DIV_STAT_CHANGING) | \
+				DIV_GPL(DIV_STAT_CHANGING))
+
+/* CLK_SRC_RIGHTBUS */
+#define MUX_GDR_SEL(x)            ((x) & 0x1)
+#define MUX_MPLL_USER_SEL_R(x)    (((x) & 0x1) << 4)
+
+/* CLK_MUX_STAT_RIGHTBUS */
+#define GDR_SEL(x)                ((x) & 0x7)
+#define MPLL_USER_SEL_R(x)        (((x) & 0x7) << 4)
+
+#define MUX_STAT_RIGHTBUS_CHANGING    (GDR_SEL(MUX_STAT_CHANGING) | \
+				MPLL_USER_SEL_R(MUX_STAT_CHANGING))
+
+/* CLK_DIV_RIGHTBUS */
+#define GPR_RATIO(x)         ((x) & 0x7)
+#define GDR_RATIO(x)         (((x) & 0x7) << 4)
+
+/* CLK_DIV_STAT_RIGHTBUS */
+#define DIV_GDR(x)           ((x) & 0x1)
+#define DIV_GPR(x)           ((x) & 0x1)
+
+#define DIV_STAT_RIGHTBUS_CHANGING    (DIV_GDR(DIV_STAT_CHANGING) | \
+				DIV_GPR(DIV_STAT_CHANGING))
+
+/* CLK_SRC_PERIL0 */
+#define UART0_SEL(x)        ((x) & 0xf)
+#define UART1_SEL(x)        (((x) & 0xf) << 4)
+#define UART2_SEL(x)        (((x) & 0xf) << 8)
+#define UART3_SEL(x)        (((x) & 0xf) << 12)
+#define UART4_SEL(x)        (((x) & 0xf) << 16)
+
+/* CLK_DIV_PERIL0 */
+#define UART0_RATIO(x)      ((x) & 0xf)
+#define UART1_RATIO(x)      (((x) & 0xf) << 4)
+#define UART2_RATIO(x)      (((x) & 0xf) << 8)
+#define UART3_RATIO(x)      (((x) & 0xf) << 12)
+#define UART4_RATIO(x)      (((x) & 0xf) << 16)
+
+/* CLK_DIV_STAT_PERIL0 */
+#define DIV_UART0(x)        ((x) & 0x1)
+#define DIV_UART1(x)        (((x) & 0x1) << 4)
+#define DIV_UART2(x)        (((x) & 0x1) << 8)
+#define DIV_UART3(x)        (((x) & 0x1) << 12)
+#define DIV_UART4(x)        (((x) & 0x1) << 16)
+
+#define DIV_STAT_PERIL0_CHANGING    (DIV_UART4(DIV_STAT_CHANGING) | \
+				DIV_UART3(DIV_STAT_CHANGING) | \
+				DIV_UART2(DIV_STAT_CHANGING) | \
+				DIV_UART1(DIV_STAT_CHANGING) | \
+				DIV_UART0(DIV_STAT_CHANGING))
+
+/* CLK_SRC_FSYS */
+#define MMC1_SEL(x)         (((x) & 0xf) << 4)
+#define MMC2_SEL(x)         (((x) & 0xf) << 8)
+#define MMC3_SEL(x)         (((x) & 0xf) << 12)
+#define MMC4_SEL(x)         (((x) & 0xf) << 16)
+#define MIPIHSI_SEL(x)      (((x) & 0x1) << 24)
+
+/* CLK_DIV_FSYS0 */
+#define MIPIHSI_RATIO(x)    (((x) & 0xf) << 20)
+
+/* CLK_DIV_STAT_FSYS0 */
+#define DIV_MIPIHSI(x)    (((x) & 0x1) << 20)
+
+#define DIV_STAT_FSYS0_CHANGING    (DIV_MIPIHSI(DIV_STAT_CHANGING))
+
+/* CLK_DIV_FSYS1 */
+#define MMC0_RATIO(x)       ((x) & 0xf)
+#define MMC0_PRE_RATIO(x)   (((x) & 0xff) << 8)
+#define MMC1_RATIO(x)       (((x) & 0xf) << 16)
+#define MMC1_PRE_RATIO(x)   (((x) & 0xff) << 24)
+
+/* CLK_DIV_STAT_FSYS1 */
+#define DIV_MMC0(x)         ((x) & 1)
+#define DIV_MMC0_PRE(x)     (((x) & 1) << 8)
+#define DIV_MMC1(x)         (((x) & 1) << 16)
+#define DIV_MMC1_PRE(x)     (((x) & 1) << 24)
+
+#define DIV_STAT_FSYS1_CHANGING    (DIV_MMC0(DIV_STAT_CHANGING) | \
+				DIV_MMC0_PRE(DIV_STAT_CHANGING) | \
+				DIV_MMC1(DIV_STAT_CHANGING) | \
+				DIV_MMC1_PRE(DIV_STAT_CHANGING))
+
+/* CLK_DIV_FSYS2 */
+#define MMC2_RATIO(x)       ((x) & 0xf)
+#define MMC2_PRE_RATIO(x)   (((x) & 0xff) << 8)
+#define MMC3_RATIO(x)       (((x) & 0xf) << 16)
+#define MMC3_PRE_RATIO(x)   (((x) & 0xff) << 24)
+
+/* CLK_DIV_STAT_FSYS2 */
+#define DIV_MMC2(x)         ((x) & 0x1)
+#define DIV_MMC2_PRE(x)     (((x) & 0x1) << 8)
+#define DIV_MMC3(x)         (((x) & 0x1) << 16)
+#define DIV_MMC3_PRE(x)     (((x) & 0x1) << 24)
+
+#define DIV_STAT_FSYS2_CHANGING    (DIV_MMC2(DIV_STAT_CHANGING) | \
+				DIV_MMC2_PRE(DIV_STAT_CHANGING) | \
+				DIV_MMC3(DIV_STAT_CHANGING) | \
+				DIV_MMC3_PRE(DIV_STAT_CHANGING))
+
+/* CLK_DIV_FSYS3 */
+#define MMC4_RATIO(x)       ((x) & 0x7)
+#define MMC4_PRE_RATIO(x)   (((x) & 0xff) << 8)
+
+/* CLK_DIV_STAT_FSYS3 */
+#define DIV_MMC4(x)         ((x) & 0x1)
+#define DIV_MMC4_PRE(x)     (((x) & 0x1) << 8)
+
+#define DIV_STAT_FSYS3_CHANGING    (DIV_MMC4(DIV_STAT_CHANGING) | \
+				DIV_MMC4_PRE(DIV_STAT_CHANGING))
+
+/* DMC */
+#ifdef CONFIG_CLK_800_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_200_200
+#define DRAM_CLK_200
+#endif
+#ifdef CONFIG_CLK_1000_330_165
+#define DRAM_CLK_330
+#endif
+#ifdef CONFIG_CLK_1000_400_200
+#define DRAM_CLK_400
+#endif
+
+/* Bus Configuration Register Address */
+#define ASYNC_CONFIG		0x10010350
+
+#define DIRECT_CMD_NOP	0x07000000
+#define DIRECT_CMD_ZQ	0x0a000000
+#define DIRECT_CMD_CHIP1_SHIFT	(1 << 20)
+#define MEM_TIMINGS_MSR_COUNT	4
+#define CTRL_START	(1 << 0)
+#define CTRL_DLL_ON	(1 << 1)
+#define AREF_EN		(1 << 5)
+#define DRV_TYPE	(1 << 6)
+
+struct mem_timings {
+	unsigned direct_cmd_msr[MEM_TIMINGS_MSR_COUNT];
+	unsigned timingref;
+	unsigned timingrow;
+	unsigned timingdata;
+	unsigned timingpower;
+	unsigned zqcontrol;
+	unsigned control0;
+	unsigned control1;
+	unsigned control2;
+	unsigned concontrol;
+	unsigned prechconfig;
+	unsigned memcontrol;
+	unsigned memconfig0;
+	unsigned memconfig1;
+	unsigned dll_resync;
+	unsigned dll_on;
+};
+
+/* MIU */
+/* MIU Config Register Offsets*/
+#define APB_SFR_INTERLEAVE_CONF_OFFSET	0x400
+#define APB_SFR_ARBRITATION_CONF_OFFSET	0xC00
+#define ABP_SFR_SLV_ADDRMAP_CONF_OFFSET	0x800
+#define ABP_SFR_INTERLEAVE_ADDRMAP_START_OFFSET	0x808
+#define ABP_SFR_INTERLEAVE_ADDRMAP_END_OFFSET	0x810
+#define ABP_SFR_SLV0_SINGLE_ADDRMAP_START_OFFSET	0x818
+#define ABP_SFR_SLV0_SINGLE_ADDRMAP_END_OFFSET	0x820
+#define ABP_SFR_SLV1_SINGLE_ADDRMAP_START_OFFSET	0x828
+#define ABP_SFR_SLV1_SINGLE_ADDRMAP_END_OFFSET	0x830
+
+#if (defined CONFIG_ORIGEN) || (defined CONFIG_ITOP4412)
+/* Interleave: 2Bit, Interleave_bit1: 0x15, Interleave_bit0: 0x7 */
+#define APB_SFR_INTERLEAVE_CONF_VAL	0x20001507
+#define APB_SFR_ARBRITATION_CONF_VAL	0x00000001
+#endif
+
+#define INTERLEAVE_ADDR_MAP_START_ADDR	0x40000000
+#define INTERLEAVE_ADDR_MAP_END_ADDR	0xbfffffff
+#define INTERLEAVE_ADDR_MAP_EN		0x00000001
+
+#ifdef CONFIG_MIU_1BIT_INTERLEAVED
+/* Interleave_bit0: 0xC*/
+#define APB_SFR_INTERLEAVE_CONF_VAL	0x0000000c
+#endif
+#ifdef CONFIG_MIU_2BIT_INTERLEAVED
+/* Interleave: 2Bit, Interleave_bit1: 0x15, Interleave_bit0: 0xc */
+#define APB_SFR_INTERLEAVE_CONF_VAL	0x2000150c
+#endif
+#define SLAVE0_SINGLE_ADDR_MAP_START_ADDR	0x40000000
+#define SLAVE0_SINGLE_ADDR_MAP_END_ADDR		0x7fffffff
+#define SLAVE1_SINGLE_ADDR_MAP_START_ADDR	0x80000000
+#define SLAVE1_SINGLE_ADDR_MAP_END_ADDR		0xbfffffff
+/* Enable SME0 and SME1*/
+#define APB_SFR_SLV_ADDR_MAP_CONF_VAL		0x00000006
+
+#define FORCE_DLL_RESYNC	3
+#define DLL_CONTROL_ON		1
+
+#define DIRECT_CMD1	0x00020000
+#define DIRECT_CMD2	0x00030000
+#define DIRECT_CMD3	0x00010002
+#define DIRECT_CMD4	0x00000328
+
+#define CTRL_ZQ_MODE_NOTERM	(0x1 << 0)
+#define CTRL_ZQ_START		(0x1 << 1)
+#define CTRL_ZQ_DIV		(0 << 4)
+#define CTRL_ZQ_MODE_DDS	(0x7 << 8)
+#define CTRL_ZQ_MODE_TERM	(0x2 << 11)
+#define CTRL_ZQ_FORCE_IMPN	(0x5 << 14)
+#define CTRL_ZQ_FORCE_IMPP	(0x6 << 17)
+#define CTRL_DCC		(0xE38 << 20)
+#define ZQ_CONTROL_VAL		(CTRL_ZQ_MODE_NOTERM | CTRL_ZQ_START\
+				| CTRL_ZQ_DIV | CTRL_ZQ_MODE_DDS\
+				| CTRL_ZQ_MODE_TERM | CTRL_ZQ_FORCE_IMPN\
+				| CTRL_ZQ_FORCE_IMPP | CTRL_DCC)
+
+#define ASYNC			(0 << 0)
+#define CLK_RATIO		(1 << 1)
+#define DIV_PIPE		(1 << 3)
+#define AWR_ON			(1 << 4)
+#define AREF_DISABLE		(0 << 5)
+#define DRV_TYPE_DISABLE	(0 << 6)
+#define CHIP0_NOT_EMPTY		(0 << 8)
+#define CHIP1_NOT_EMPTY		(0 << 9)
+#define DQ_SWAP_DISABLE		(0 << 10)
+#define QOS_FAST_DISABLE	(0 << 11)
+#define RD_FETCH		(0x3 << 12)
+#define TIMEOUT_LEVEL0		(0xFFF << 16)
+#define CONCONTROL_VAL		(ASYNC | CLK_RATIO | DIV_PIPE | AWR_ON\
+				| AREF_DISABLE | DRV_TYPE_DISABLE\
+				| CHIP0_NOT_EMPTY | CHIP1_NOT_EMPTY\
+				| DQ_SWAP_DISABLE | QOS_FAST_DISABLE\
+				| RD_FETCH | TIMEOUT_LEVEL0)
+
+#define CLK_STOP_DISABLE	(0 << 1)
+#define DPWRDN_DISABLE		(0 << 2)
+#define DPWRDN_TYPE		(0 << 3)
+#define TP_DISABLE		(0 << 4)
+#define DSREF_DIABLE		(0 << 5)
+#define ADD_LAT_PALL		(1 << 6)
+#define MEM_TYPE_DDR3		(0x6 << 8)
+#define MEM_WIDTH_32		(0x2 << 12)
+#define NUM_CHIP_2		(0 << 16)
+#define BL_8			(0x3 << 20)
+#define MEMCONTROL_VAL		(CLK_STOP_DISABLE | DPWRDN_DISABLE\
+				| DPWRDN_TYPE | TP_DISABLE | DSREF_DIABLE\
+				| ADD_LAT_PALL | MEM_TYPE_DDR3 | MEM_WIDTH_32\
+				| NUM_CHIP_2 | BL_8)
+
+
+#define CHIP_BANK_8		(0x3 << 0)
+#define CHIP_ROW_14		(0x3 << 4)
+#define CHIP_COL_10		(0x3 << 8)
+#define CHIP_MAP_INTERLEAVED	(1 << 12)
+#define CHIP_MASK		(0xC0 << 16)
+#ifdef CONFIG_MIU_LINEAR
+#define CHIP0_BASE		(0x40 << 24)
+#define CHIP1_BASE		(0x60 << 24)
+#else
+#define CHIP0_BASE		(0x40 << 24)
+#define CHIP1_BASE		(0x80 << 24)
+#endif
+#define MEMCONFIG0_VAL		(CHIP_BANK_8 | CHIP_ROW_14 | CHIP_COL_10\
+				| CHIP_MAP_INTERLEAVED | CHIP_MASK | CHIP0_BASE)
+#define MEMCONFIG1_VAL		(CHIP_BANK_8 | CHIP_ROW_14 | CHIP_COL_10\
+				| CHIP_MAP_INTERLEAVED | CHIP_MASK | CHIP1_BASE)
+
+#define TP_CNT			(0xff << 24)
+#define PRECHCONFIG		TP_CNT
+
+#define CTRL_OFF		(0 << 0)
+#define CTRL_DLL_OFF		(0 << 1)
+#define CTRL_HALF		(0 << 2)
+#define CTRL_DFDQS		(1 << 3)
+#define DQS_DELAY		(0 << 4)
+#define CTRL_START_POINT	(0x10 << 8)
+#define CTRL_INC		(0x10 << 16)
+#define CTRL_FORCE		(0x71 << 24)
+#define CONTROL0_VAL		(CTRL_OFF | CTRL_DLL_OFF | CTRL_HALF\
+				| CTRL_DFDQS | DQS_DELAY | CTRL_START_POINT\
+				| CTRL_INC | CTRL_FORCE)
+
+#define CTRL_SHIFTC		(0x6 << 0)
+#define CTRL_REF		(8 << 4)
+#define CTRL_SHGATE		(1 << 29)
+#define TERM_READ_EN		(1 << 30)
+#define TERM_WRITE_EN		(1 << 31)
+#define CONTROL1_VAL		(CTRL_SHIFTC | CTRL_REF | CTRL_SHGATE\
+				| TERM_READ_EN | TERM_WRITE_EN)
+
+#define CONTROL2_VAL		0x00000000
+
+#ifdef CONFIG_ITOP4412
+#define TIMINGREF_VAL		0x000000BB
+#define TIMINGROW_VAL		0x4046654f
+#define	TIMINGDATA_VAL		0x46400506
+#define	TIMINGPOWER_VAL		0x52000A3C
+#else
+#define TIMINGREF_VAL		0x000000BC
+#ifdef DRAM_CLK_330
+#define TIMINGROW_VAL		0x3545548d
+#define	TIMINGDATA_VAL		0x45430506
+#define	TIMINGPOWER_VAL		0x4439033c
+#endif
+#ifdef DRAM_CLK_400
+#define TIMINGROW_VAL		0x45430506
+#define	TIMINGDATA_VAL		0x56500506
+#define	TIMINGPOWER_VAL		0x5444033d
+#endif
+#endif
+
+#ifdef CONFIG_BOARD_TYPES
+extern void sdelay(unsigned long);
+#endif
+
+
+#endif
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/lowlevel_init.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/lowlevel_init.c
--- u-boot-2017.11/arch/arm/mach-exynos/lowlevel_init.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/lowlevel_init.c	2018-10-29 14:02:49.000000000 +0800
@@ -215,15 +215,23 @@ int do_lowlevel_init(void)
 
 	if (actions & DO_CLOCKS) {
 		system_clock_init();
+
 #ifdef CONFIG_DEBUG_UART
-#if (defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_SERIAL_SUPPORT)) || \
-    !defined(CONFIG_SPL_BUILD)
+#if (defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_SERIAL_SUPPORT)) || !defined(CONFIG_SPL_BUILD)
+    
+#ifdef CONFIG_ITOP4412
+		exynos_pinmux_config(PERIPH_ID_UART2, PINMUX_FLAG_NONE);
+#else
 		exynos_pinmux_config(PERIPH_ID_UART3, PINMUX_FLAG_NONE);
+#endif
 		debug_uart_init();
 #endif
 #endif
 		mem_ctrl_init(actions & DO_MEM_RESET);
+
+#ifndef CONFIG_ITOP4412
 		tzpc_init();
+#endif
 	}
 
 	return actions & DO_WAKEUP;
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/power.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/power.c
--- u-boot-2017.11/arch/arm/mach-exynos/power.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/power.c	2018-08-24 13:21:56.000000000 +0800
@@ -163,6 +163,27 @@ static void exynos5_set_ps_hold_ctrl(voi
 			EXYNOS_PS_HOLD_CONTROL_DATA_HIGH);
 }
 
+#ifdef CONFIG_ITOP4412
+static void exynos4x12_set_ps_hold_ctrl(void)
+{
+	struct exynos4x12_power *power = 
+		(struct exynos4x12_power *)samsung_get_base_power();
+
+	/* value: 1000000000B */
+	setbits_le32(&power->ps_hold_control, EXYNOS_PS_HOLD_CONTROL_DATA_HIGH);
+
+	/**
+	 * GPX0PUD register
+	 *
+	 * 0x0 = Disables Pull-up/Pull-down
+	 * 0x1 = Enables Pull-down
+	 * 0x2 = Reserved
+	 * 0x3 = Enables Pull-up
+	 */
+	writel(0x3, (unsigned int *)0x11000c08);
+}
+#endif
+
 /*
  * Set ps_hold data driving value high
  * This enables the machine to stay powered on
@@ -173,9 +194,12 @@ void set_ps_hold_ctrl(void)
 {
 	if (cpu_is_exynos5())
 		exynos5_set_ps_hold_ctrl();
+#ifdef CONFIG_ITOP4412
+	else if (cpu_is_exynos4())
+		exynos4x12_set_ps_hold_ctrl();
+#endif
 }
 
-
 static void exynos5_set_xclkout(void)
 {
 	struct exynos5_power *power =
diff -rupN u-boot-2017.11/arch/arm/mach-exynos/spl_boot.c u-boot-2017.11-itop4412/arch/arm/mach-exynos/spl_boot.c
--- u-boot-2017.11/arch/arm/mach-exynos/spl_boot.c	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/arch/arm/mach-exynos/spl_boot.c	2018-10-29 14:02:36.000000000 +0800
@@ -227,10 +227,12 @@ void copy_uboot_to_ram(void)
 		copy_bl2 = get_irom_func(MMC_INDEX);
 		break;
 #ifdef CONFIG_SUPPORT_EMMC_BOOT
-	case BOOT_MODE_EMMC:
+	case BOOT_MODE_EMMC_SD:
 		/* Set the FSYS1 clock divisor value for EMMC boot */
+#ifndef CONFIG_ITOP4412
+		/* just for exynos5 can be call */
 		emmc_boot_clk_div_set();
-
+#endif
 		copy_bl2_from_emmc = get_irom_func(EMMC44_INDEX);
 		end_bootop_from_emmc = get_irom_func(EMMC44_END_INDEX);
 
@@ -294,7 +296,6 @@ void board_init_f(unsigned long bootflag
 		power_exit_wakeup();
 
 	copy_uboot_to_ram();
-
 	/* Jump to U-Boot image */
 	uboot = (void *)CONFIG_SYS_TEXT_BASE;
 	(*uboot)();
diff -rupN u-boot-2017.11/board/samsung/itop4412/Kconfig u-boot-2017.11-itop4412/board/samsung/itop4412/Kconfig
--- u-boot-2017.11/board/samsung/itop4412/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/Kconfig	2018-07-10 16:27:56.000000000 +0800
@@ -0,0 +1,12 @@
+if TARGET_ITOP4412
+
+config SYS_BOARD
+	default "itop4412"
+
+config SYS_VENDOR
+	default "samsung"
+
+config SYS_CONFIG_NAME
+	default "itop4412"
+
+endif
diff -rupN u-boot-2017.11/board/samsung/itop4412/MAINTAINERS u-boot-2017.11-itop4412/board/samsung/itop4412/MAINTAINERS
--- u-boot-2017.11/board/samsung/itop4412/MAINTAINERS	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/MAINTAINERS	2018-07-10 16:31:35.000000000 +0800
@@ -0,0 +1,6 @@
+ITOP4412 BOARD
+M:	Chander Kashyap <k.chander@samsung.com>
+S:	Maintained
+F:	board/samsung/itop4412/
+F:	include/configs/itop4412.h
+F:	configs/itop4412_defconfig
diff -rupN u-boot-2017.11/board/samsung/itop4412/Makefile u-boot-2017.11-itop4412/board/samsung/itop4412/Makefile
--- u-boot-2017.11/board/samsung/itop4412/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/Makefile	2018-07-10 16:36:17.000000000 +0800
@@ -0,0 +1,22 @@
+#
+# Copyright (C) 2011 Samsung Electronics
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+ifdef CONFIG_SPL_BUILD
+# necessary to create built-in.o
+obj- := __dummy__.o
+
+hostprogs-y := tools/mkitop4412spl
+always := $(hostprogs-y)
+
+# omit -O2 option to suppress
+#   warning: dereferencing type-punned pointer will break strict-aliasing rules
+#
+# TODO:
+# Fix the root cause in tools/mkitop4412spl.c and delete the following work-around
+$(obj)/tools/mkitop4412spl: HOSTCFLAGS:=$(filter-out -O2,$(HOSTCFLAGS))
+else
+obj-y	+= itop4412.o
+endif
diff -rupN u-boot-2017.11/board/samsung/itop4412/itop4412.c u-boot-2017.11-itop4412/board/samsung/itop4412/itop4412.c
--- u-boot-2017.11/board/samsung/itop4412/itop4412.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/itop4412.c	2018-08-07 10:01:02.000000000 +0800
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <asm/arch/cpu.h>
+#include <asm/arch/mmc.h>
+#include <asm/arch/periph.h>
+#include <asm/arch/pinmux.h>
+#include <usb.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+u32 get_board_rev(void)
+{
+	return 0;
+}
+
+int exynos_init(void)
+{
+	return 0;
+}
+
+int board_usb_init(int index, enum usb_init_type init)
+{
+	return 0;
+}
+
+#ifdef CONFIG_BOARD_EARLY_INIT_F
+int exynos_early_init_f(void)
+{
+	return 0;
+}
+#endif
diff -rupN u-boot-2017.11/board/samsung/itop4412/tools/mkitop4412spl.c u-boot-2017.11-itop4412/board/samsung/itop4412/tools/mkitop4412spl.c
--- u-boot-2017.11/board/samsung/itop4412/tools/mkitop4412spl.c	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/board/samsung/itop4412/tools/mkitop4412spl.c	2018-07-13 16:20:52.000000000 +0800
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <string.h>
+#include <sys/stat.h>
+
+#define BUFSIZE			(16*1024)
+#define IMG_SIZE		(14*1024) //16*1024
+#define SPL_HEADER_SIZE		0 //16
+#define FILE_PERM		(S_IRUSR | S_IWUSR | S_IRGRP \
+				| S_IWGRP | S_IROTH | S_IWOTH)
+#define SPL_HEADER		"S5PC210 HEADER  "
+/*
+* Requirement:
+* IROM code reads first 14K bytes from boot device.
+* It then calculates the checksum of 14K-4 bytes and compare with data at
+* 14K-4 offset.
+*
+* This function takes two filenames:
+* IN  "u-boot-spl.bin" and
+* OUT "$(BOARD)-spl.bin as filenames.
+* It reads the "u-boot-spl.bin" in 16K buffer.
+* It calculates checksum of 14K-4 Bytes and stores at 14K-4 offset in buffer.
+* It writes the buffer to "$(BOARD)-spl.bin" file.
+*/
+
+int main(int argc, char **argv)
+{
+	int i, len;
+	unsigned char buffer[BUFSIZE] = {0};
+	int ifd, ofd;
+	unsigned int checksum = 0, count;
+
+	if (argc != 3) {
+		printf(" %d Wrong number of arguments\n", argc);
+		exit(EXIT_FAILURE);
+	}
+
+	ifd = open(argv[1], O_RDONLY);
+	if (ifd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+		exit(EXIT_FAILURE);
+	}
+
+	ofd = open(argv[2], O_WRONLY | O_CREAT | O_TRUNC, FILE_PERM);
+	if (ofd < 0) {
+		fprintf(stderr, "%s: Can't open %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+		if (ifd)
+			close(ifd);
+		exit(EXIT_FAILURE);
+	}
+
+	len = lseek(ifd, 0, SEEK_END);
+	lseek(ifd, 0, SEEK_SET);
+
+	memcpy(&buffer[0], SPL_HEADER, SPL_HEADER_SIZE);
+
+	count = (len < (IMG_SIZE - SPL_HEADER_SIZE))
+		? len : (IMG_SIZE - SPL_HEADER_SIZE);
+
+	if (read(ifd, buffer + SPL_HEADER_SIZE, count) != count) {
+		fprintf(stderr, "%s: Can't read %s: %s\n",
+			argv[0], argv[1], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+	
+#if 0
+	for (i = 0; i < IMG_SIZE - SPL_HEADER_SIZE; i++)
+		checksum += buffer[i+16];
+
+	*(unsigned long *)buffer ^= 0x1f;
+	*(unsigned long *)(buffer+4) ^= checksum;
+
+	for (i = 1; i < SPL_HEADER_SIZE; i++)
+		buffer[i] ^= buffer[i-1];
+#endif
+
+	for (i = 0; i < IMG_SIZE - 4; i++)
+		checksum += (unsigned char)buffer[i];
+
+	*(unsigned int *)&buffer[i] = checksum;
+
+	if (write(ofd, buffer, BUFSIZE) != BUFSIZE) {
+		fprintf(stderr, "%s: Can't write %s: %s\n",
+			argv[0], argv[2], strerror(errno));
+
+		if (ifd)
+			close(ifd);
+		if (ofd)
+			close(ofd);
+
+		exit(EXIT_FAILURE);
+	}
+
+	if (ifd)
+		close(ifd);
+	if (ofd)
+		close(ofd);
+
+	return EXIT_SUCCESS;
+}
diff -rupN u-boot-2017.11/configs/itop4412_defconfig u-boot-2017.11-itop4412/configs/itop4412_defconfig
--- u-boot-2017.11/configs/itop4412_defconfig	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/configs/itop4412_defconfig	2018-10-11 18:33:21.000000000 +0800
@@ -0,0 +1,55 @@
+CONFIG_ARM=y
+CONFIG_ARCH_EXYNOS=y
+CONFIG_ARCH_EXYNOS4=y
+CONFIG_TARGET_ITOP4412=y
+CONFIG_SPL_GPIO_SUPPORT=y
+CONFIG_SPL_SERIAL_SUPPORT=y
+CONFIG_IDENT_STRING=" for itop-4412"
+CONFIG_DEFAULT_DEVICE_TREE="exynos4412-itop4412"
+CONFIG_DEBUG_UART=y
+CONFIG_SD_BOOT=y
+CONFIG_BOOTDELAY=5
+CONFIG_SYS_CONSOLE_IS_IN_ENV=y
+CONFIG_SYS_CONSOLE_INFO_QUIET=y
+CONFIG_SPL=y
+CONFIG_HUSH_PARSER=y
+CONFIG_SYS_PROMPT="u-boot # "
+CONFIG_CMD_BOOTZ=y
+# CONFIG_CMD_XIMG is not set
+CONFIG_CMD_THOR_DOWNLOAD=y
+CONFIG_CMD_DFU=y
+# CONFIG_CMD_FPGA is not set
+CONFIG_CMD_GPT=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+# CONFIG_CMD_NET is not set
+CONFIG_CMD_DHCP=y
+# CONFIG_CMD_NFS is not set
+CONFIG_CMD_MII=y
+CONFIG_CMD_CACHE=y
+# CONFIG_CMD_MISC is not set
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_ISO_PARTITION=y
+CONFIG_OF_CONTROL=y
+CONFIG_DFU_MMC=y
+CONFIG_DM_MMC=y
+CONFIG_MMC_DW=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_SDMA=y
+CONFIG_MMC_SDHCI_S5P=y
+CONFIG_DEBUG_UART_S5P=y
+CONFIG_DEBUG_UART_BASE=0x13820000
+CONFIG_DEBUG_UART_CLOCK=100000000
+CONFIG_USB=y
+CONFIG_DM_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_GADGET_MANUFACTURER="Samsung"
+CONFIG_USB_GADGET_VENDOR_NUM=0x04e8
+CONFIG_USB_GADGET_PRODUCT_NUM=0x6601
+CONFIG_USB_GADGET_DWC2_OTG=y
+CONFIG_USB_GADGET_DOWNLOAD=y
diff -rupN u-boot-2017.11/include/configs/itop4412.h u-boot-2017.11-itop4412/include/configs/itop4412.h
--- u-boot-2017.11/include/configs/itop4412.h	1970-01-01 08:00:00.000000000 +0800
+++ u-boot-2017.11-itop4412/include/configs/itop4412.h	2018-10-29 11:39:14.000000000 +0800
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) 2011 Samsung Electronics
+ *
+ * Configuration settings for the SAMSUNG ITOP4412 (EXYNOS4412) board.
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef __CONFIG_ITOP4412_H
+#define __CONFIG_ITOP4412_H
+
+#include <configs/exynos4-common.h>
+
+#define CONFIG_SUPPORT_EMMC_BOOT 1
+
+/* High Level Configuration Options */
+#define CONFIG_EXYNOS4210		1	/* which is a EXYNOS4210 SoC */
+#define CONFIG_ITOP4412			1	/* working with ITOP4412*/
+
+#define CONFIG_SYS_DCACHE_OFF		1
+
+/* itop-4412 has 4 bank of DRAM */
+#define CONFIG_NR_DRAM_BANKS		4
+#define CONFIG_SYS_SDRAM_BASE		0x40000000
+#define PHYS_SDRAM_1			CONFIG_SYS_SDRAM_BASE
+#define SDRAM_BANK_SIZE			(256 << 20)	/* 256 MB */
+
+/* memtest works on */
+#define CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x6000000)
+#define CONFIG_SYS_LOAD_ADDR		(CONFIG_SYS_SDRAM_BASE + 0x00100000)
+
+#define CONFIG_SYS_TEXT_BASE		0x43E00000
+
+/* #define MACH_TYPE_ITOP4412		0xffffffff */
+#define CONFIG_MACH_TYPE		MACH_TYPE_ITOP4412
+
+/* select serial console configuration */
+#define CONFIG_SERIAL2
+
+/* Console configuration */
+#define CONFIG_DEFAULT_CONSOLE		"console=ttySAC1,115200n8\0"
+
+#define CONFIG_SYS_MEM_TOP_HIDE	(1 << 20)	/* ram console */
+
+#define CONFIG_SYS_MONITOR_BASE	0x00000000
+
+/* Power Down Modes */
+#define S5P_CHECK_SLEEP			0x00000BAD
+#define S5P_CHECK_DIDLE			0xBAD00000
+#define S5P_CHECK_LPA			0xABAD0000
+
+#define CONFIG_SUPPORT_RAW_INITRD
+
+/* MMC SPL */
+#define COPY_BL2_FNPTR_ADDR		0x02020030
+#define CONFIG_SPL_TEXT_BASE	0x02023400 /* 0x02021410 */
+
+#define CONFIG_EXTRA_ENV_SETTINGS \
+	"loadaddr=0x40007000\0" \
+	"rdaddr=0x48000000\0" \
+	"kerneladdr=0x40007000\0" \
+	"ramdiskaddr=0x48000000\0" \
+	"console=ttySAC2,115200n8\0" \
+	"mmcdev=0\0" \
+	"bootenv=uEnv.txt\0" \
+	"dtb_addr=0x41000000\0" \
+	"dtb_name=exynos4412-itop-4412.dtb\0" \
+	"loadbootenv=load mmc ${mmcdev} ${loadaddr} ${bootenv}\0" \
+	"bootargs=console=ttySAC2,115200n8 earlyprintk\0" \
+	"importbootenv=echo Importing environment from mmc ...; " \
+	"env import -t $loadaddr $filesize\0" \
+    "loadbootscript=load mmc ${mmcdev} ${loadaddr} boot.scr\0" \
+    "bootscript=echo Running bootscript from mmc${mmcdev} ...; " \
+    "source ${loadaddr}\0"
+#define CONFIG_BOOTCOMMAND \
+	"if mmc rescan; then " \
+		"echo SD/MMC found on device ${mmcdev};" \
+		"if run loadbootenv; then " \
+			"echo Loaded environment from ${bootenv};" \
+			"run importbootenv;" \
+		"fi;" \
+		"if test -n $uenvcmd; then " \
+			"echo Running uenvcmd ...;" \
+			"run uenvcmd;" \
+		"fi;" \
+		"if run loadbootscript; then " \
+			"run bootscript; " \
+		"fi; " \
+	"fi;" \
+	"mmc read ${loadaddr} 0x1000 0x4000; mmc read ${dtb_addr} 0x800 0xa0; bootm ${loadaddr} - ${dtb_addr}" \
+	"load mmc ${mmcdev} ${loadaddr} uImage; load mmc ${mmcdev} ${dtb_addr} ${dtb_name}; bootm ${loadaddr} - ${dtb_addr}"
+
+#define CONFIG_CLK_1000_400_200
+
+/* MIU (Memory Interleaving Unit) */
+#define CONFIG_MIU_2BIT_21_7_INTERLEAVED
+
+#define CONFIG_SYS_MMC_ENV_DEV		1
+#define CONFIG_ENV_SIZE				(8 << 10) /* 8 KB */
+#define RESERVE_BLOCK_SIZE			(512)
+#define BL1_SIZE					(8 << 10) /* 8 K reserved for BL1 */
+#define BL2_SIZE					(16 << 10) /* 16 K reserved for BL2 */
+#define CONFIG_ENV_OFFSET			(RESERVE_BLOCK_SIZE + BL1_SIZE + BL2_SIZE)
+
+#define CONFIG_SPL_MAX_FOOTPRINT	(14 * 1024)
+
+#define CONFIG_SPL_STACK			0x02040000
+#define UBOOT_SIZE					(2 << 20)
+#define CONFIG_SYS_INIT_SP_ADDR		(CONFIG_SYS_TEXT_BASE + UBOOT_SIZE - 0x1000)
+
+/* U-Boot copy size from boot Media to DRAM. */
+#define COPY_BL2_SIZE		0x80000
+#define BL2_START_OFFSET	((CONFIG_ENV_OFFSET + CONFIG_ENV_SIZE)/512)
+#define BL2_SIZE_BLOC_COUNT	(COPY_BL2_SIZE / 512)
+
+#endif	/* __CONFIG_H */
diff -rupN u-boot-2017.11/scripts/config_whitelist.txt u-boot-2017.11-itop4412/scripts/config_whitelist.txt
--- u-boot-2017.11/scripts/config_whitelist.txt	2017-11-14 09:08:06.000000000 +0800
+++ u-boot-2017.11-itop4412/scripts/config_whitelist.txt	2018-11-11 10:31:59.332011700 +0800
@@ -1096,6 +1096,7 @@ CONFIG_IRDA_BASE
 CONFIG_IS_BUILTIN
 CONFIG_IS_ENABLED
 CONFIG_IS_MODULE
+CONFIG_ITOP4412
 CONFIG_JFFS2_CMDLINE
 CONFIG_JFFS2_DEV
 CONFIG_JFFS2_LZO
